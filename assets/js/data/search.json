[
  
  {
    "title": "CMake - Adding Libraries",
    "url": "/posts/CMake-Adding-Libraries/",
    "categories": "software, C++, cmake",
    "tags": "software, c++, cmake, windows",
    "date": "2023-11-15 17:08:00 +0100",
    





    
    "snippet": "This post delves into the steps required to integrate several widely-used C++ libraries into your project using CMake. We will explore the setup and usage of Google Test, Google Benchmark, OpenCV, ...",
    "content": "This post delves into the steps required to integrate several widely-used C++ libraries into your project using CMake. We will explore the setup and usage of Google Test, Google Benchmark, OpenCV, PkgFinder, GStreamer, and Catch2.1. Google Test1.1 Using FetchContentGoogle Test is a popular testing framework for C++. Below is the procedure to integrate Google Test using CMake’s FetchContent module within your CMakeLists.txt file:include(FetchContent)         # to use FetchContent_Declare# -- START: GOOGLE_TEST_INCLUDE --FetchContent_Declare(    googletest    GIT_REPOSITORY https://github.com/google/googletest.git    GIT_TAG main    OVERRIDE_FIND_PACKAGE)FetchContent_MakeAvailable(googletest)include(GoogleTest)         # to use gtest_discover_teststarget_link_libraries(simple_test GTest::gtest_main)# -- END: GOOGLE_TEST_INCLUDE --# test filesadd_executable(simple_test \"simple_test.cpp\")gtest_discover_tests(simple_test)Below is an example of a simple Google Test implementation in simple_test.cpp:# include &lt;gtest/gtest.h&gt;TEST(HelloTest, BasicAssertions) {    // Expect two strings not to be equal.    EXPECT_STRNE(\"hello\", \"world\");    // Expect equality.    EXPECT_EQ(7 * 6, 42);}2. Google Benchmark2.1 Using FetchContentGoogle Benchmark is a library designed to support the benchmarking of C++ code. The following CMake configuration demonstrates how to add Google Benchmark to your project:include(FetchContent)   # to use FetchContent_Declare# -- START: GOOGLE_BENCHMARK_INCLUDE --FetchContent_Declare(    googlebenchmark    GIT_REPOSITORY https://github.com/google/benchmark.git    GIT_TAG main    OVERRIDE_FIND_PACKAGE)FetchContent_MakeAvailable(googlebenchmark)target_link_libraries(${EXE_NAME} benchmark::benchmark)# -- END: GOOGLE_BENCHMARK_INCLUDE --# test filesadd_executable(simple_test \"simple_test.cpp\")gtest_discover_tests(simple_test)Example benchmarking code in simple_benchmark.cpp:#include &lt;benchmark/benchmark.h&gt;static void BM_StringCreation(benchmark::State&amp; state) {  for (auto _ : state)    std::string empty_string;}// Register the function as a benchmarkBENCHMARK(BM_StringCreation);static void BM_StringCopy(benchmark::State&amp; state) {  std::string x = \"hello\";  for (auto _ : state)    std::string copy(x);}BENCHMARK(BM_StringCopy);3. OpenCVTo integrate OpenCV into your C++ project using the MinGW64 compiler, follow these steps:  Download and extract the OpenCV-MinGW build from the following repository: OpenCV-MinGW-Build  Ensure that Python 3.x is installed on your system.  Add the OpenCV binary folder to your system’s PATH environment variable.Update your CMakeLists.txt to include and link OpenCV:# Add thisset(OpenCV_DIR \"C:\\\\OpenCV-MinGW-Build-OpenCV-4.5.5-x64\")# Find and link OpenCVfind_package(OpenCV REQUIRED)target_include_directories(MyApp PRIVATE ${OpenCV_INCLUDE_DIRS})target_link_libraries(MyApp PRIVATE ${OpenCV_LIBS} )Sample OpenCV code:#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char *argv[]) {     // Create a window using OpenCV     cv::namedWindow(\"MyWindow\", cv::WINDOW_AUTOSIZE);     // Wait for a keystroke in the window     cv::waitKey(0);    return 0;}4. PkgFinder Package for CMakeTo integrate libraries using PkgConfig, you’ll need to install the required binaries. Copy the following files into your MinGW64 bin directory:  bin/pkg-config.exe from pkg-config_0.26-1_win32.zip  bin/intl.dll from gettext-runtime_0.18.1.1-2_win32.zip  bin/libglib-2.0-0.dll from glib_2.28.8-1_win32.zip5. GStreamerGstream requires PkgFinder packe for CMakeTo use GStreamer in your C++ projects, ensure the following:      Install the Microsoft Visual C++ Redistributable: vc_redist.x86.exe        Download and install the GStreamer runtime and SDK (MSVC-64 version) from here.        Add the GStreamer binary folder to the system PATH environment variable.        Set the PKG_CONFIG_PATH environment variable to the GStreamer package config path: PKG_CONFIG_PATH = ..\\gstreamer\\1.0\\msvc_x86_64\\lib\\pkgconfig`  Update your CMakeLists.txt:# ...find_package(PkgConfig REQUIRED)pkg_check_modules(GST REQUIRED gstreamer-1.0)pkg_search_module(GSTREAMER REQUIRED IMPORTED_TARGET gstreamer-1.0&gt;=1.4)target_include_directories(${PROJECT_NAME} PRIVATE  ${GST_INCLUDE_DIRS})target_link_libraries(${PROJECT_NAME} PRIVATE PkgConfig::GSTREAMER)6. Catch26.1 Downloading and Installing Catch2Catch2 is another popular testing framework. To add Catch2 to your project, clone the repository and build it:git clone https://github.com/catchorg/Catch2.gitcd Catch2# if you want a specific versiongit checkout v2.13.9Build and install the library:mkdir build &amp;&amp; cd buildcmake .. -G \"MinGW Makefiles\"cmake --build . --target install  # This adds the package to CMakeBy following these instructions, you should be able to seamlessly integrate these libraries into your C++ projects using CMake."
  },
  
  {
    "title": "CMake On Windows",
    "url": "/posts/CMake-On-Windows/",
    "categories": "software, C++, cmake",
    "tags": "software, c++, cmake, windows",
    "date": "2023-09-19 16:18:00 +0200",
    





    
    "snippet": "Here is a quick way to get started into development with CMake on Windows x64.1. Getting Started1.1 Downloads  Download MinGW64 (posix, seh, msvcrt) from here.  Download CMake (Windows x64) from he...",
    "content": "Here is a quick way to get started into development with CMake on Windows x64.1. Getting Started1.1 Downloads  Download MinGW64 (posix, seh, msvcrt) from here.  Download CMake (Windows x64) from here.1.2 Installation  Install CMake in C:\\Program Files\\Cmake.  Copy the minGW64 folder into C:\\.  Add the following binary paths to the PATH variable:          C:\\minGW64\\bin      C:\\Program Files\\Cmake\\bin      1.3 First Project  The simplest project to build is a Hello world program. Hence we will add a main.cpp source:#include &lt;iostream&gt;int main() {    std::cout &lt;&lt; \"Hello World!\\n\";    return 0;}  The corresponding cmake instruction would be the file CMakeLists.txt:cmake_minimum_required(VERSION 3.10)# Project Nameproject(HelloWorld)# Add an executable with sourcesadd_executable(    ${PROJECT_NAME} main.cpp)  To build the project now you should run the following commands# compilemkdir buildcd buildcmake .. -G \"MinGW Makefiles\"   # Makefile for minGWmingw32-make# cleancd ..rmdir /s /q buildMore  Check out the Quick reference for more.  Check out the the Minimum CMakeLists.txt Template."
  },
  
  {
    "title": "CMake - Brief Reference",
    "url": "/posts/CMake-Brief-Reference/",
    "categories": "software, C++, cmake",
    "tags": "software, c++, cmake, reference",
    "date": "2023-09-19 15:12:00 +0200",
    





    
    "snippet": "CMake is a powerful and flexible build system generator that supports the creation of makefiles, project files, and build environments across various platforms and compilers. Below is a brief refer...",
    "content": "CMake is a powerful and flexible build system generator that supports the creation of makefiles, project files, and build environments across various platforms and compilers. Below is a brief reference guide to some essential commands and patterns commonly used in CMake.Key Commands and ConceptsProject DefinitionCMake allows for detailed configuration of your project. Below are different levels of project definition:  Basic Project Definition: Defines the project name.project(MyProjectName)  Project with Versioning: Specifies the project name along with its version.project(MyProjectName VERSION 1.0.0)  Comprehensive Project Configuration: Provides additional details such as the languages used, a brief description, and a homepage URL.project(  MyProjectName   VERSION 1.0.0  LANGUAGES C CXX ASM Fortran CUDA  DESCRIPTION \"This is a sample project\"  HOMEPAGE_URL \"https://example.com\")VariablesVariables in CMake are fundamental for managing values and passing data throughout the CMakeLists.txt files.Definition  Basic Variable: Sets a variable with a specified value. Scoping can be controlled by specifying the parent scope.set(VARIABLE_NAME \"Value\")                  # local scopeset(VARIABLE_NAME \"Value\" PARENT_SCOPE)     # parent scope  List Variable: Commonly used for defining lists of source files.set(SOURCES main.cpp MyClass.cpp AnotherClass.cpp)Appending to Variables  Appending Values: Adds new values to an existing list.set(SOURCES ${SOURCES} YetAnotherClass.cpp) # Traditional waylist(APPEND SOURCES YetAnotherClass.cpp)    # using APPENDExecutable ConfigurationDefining and managing executables within your project can be easily achieved through CMake:  Basic Executable: Defines an executable from a single source file.add_executable(my_executable main.cpp)  Multiple Source Files: Creates an executable from multiple source files.add_executable(my_executable ${SOURCES})  Conditional Source Files: Dynamically adds source files based on platform or other conditions.if(WIN32)    list(APPEND SOURCES win_main.cpp)else()    list(APPEND SOURCES unix_main.cpp)endif()add_executable(my_app ${SOURCES})  Setting Executable Properties: Configures specific properties, such as the C++ standard required.add_executable(my_app main.cpp)set_target_properties(my_app PROPERTIES    CXX_STANDARD 11    CXX_STANDARD_REQUIRED YES    CXX_EXTENSIONS NO)Including DirectoriesCMake offers flexible methods to manage include directories, ensuring that the compiler can locate the necessary header files:  Global Include Directory: This approach sets include directories globally, but it is generally discouraged due to its potential to introduce conflicts.include_directories(${CMAKE_SOURCE_DIR}/include)    # bad practice  Target-Specific Include Directory: Specifies include directories for a specific target, promoting better encapsulation and avoiding global scope issues.add_executable(my_app main.cpp)target_include_directories(my_app PRIVATE ${CMAKE_SOURCE_DIR}/include)Library ManagementLibraries are crucial in C++ projects, and CMake provides robust commands for adding and linking libraries effectively:Adding Libraries  Static Library: Creates a static library from specified source files.add_library(my_static_lib STATIC src/lib.cpp)  Shared Library: Creates a shared library.add_library(my_shared_lib SHARED src/lib.cpp)  Module Library: Creates a library that is loaded dynamically at runtime.add_library(my_shared_lib MODULE src/lib.cpp)  Object Library: Compiles sources into object files without archiving or linking them into a library.add_library(my_shared_lib OBJECT src/lib.cpp)Linking Libraries  Linking to an Executable: Links a library to an executable.add_executable(my_app main.cpp)add_library(my_lib STATIC src/lib.cpp)target_link_libraries(my_app PRIVATE my_lib)  Linking System Libraries: Links against a system-provided library.find_library(MATH_LIB m)if(MATH_LIB)    target_link_libraries(my_app PRIVATE ${MATH_LIB})endif()  Importing External Libraries: Allows the use of an external library in your project.add_library(external_lib UNKNOWN IMPORTED)set_target_properties(external_lib PROPERTIES  IMPORTED_LOCATION \"/path/to/external_lib.a\"  INTERFACE_INCLUDE_DIRECTORIES \"/path/to/includes\")  Known Libraries: Examples of linking against some well-known libraries. (Examples for Threads, Catch2, OpenCV, Google Benchmark, and Eigen provided)Predefined Variables  CMAKE_SOURCE_DIR: The top-level source directory.message(\"Top-level source directory: ${CMAKE_SOURCE_DIR}\")  CMAKE_BINARY_DIR: The top-level build directory (usually the directory where you invoked CMake).message(\"Binary directory: ${CMAKE_BINARY_DIR}\")  CMAKE_CURRENT_SOURCE_DIR: The source directory of the current CMakeLists.txt.include(${CMAKE_CURRENT_SOURCE_DIR}/extra.cmake)  CMAKE_CURRENT_BINARY_DIR: The build directory corresponding to the current source directory.set(EXECUTABLE_OUTPUT_PATH ${CMAKE_CURRENT_BINARY_DIR}/bin)  CMAKE_PROJECT_NAME: The name of the first project set in the top-level CMakeLists.txt.message(\"Top level project: ${CMAKE_PROJECT_NAME}\")  CMAKE_CXX_COMPILER: The full path to the C++ compiler.message(\"Using compiler: ${CMAKE_CXX_COMPILER}\")  CMAKE_C_COMPILER: The full path to the C++ compiler.message(\"Using compiler: ${CMAKE_C_COMPILER}\")  CMAKE_PREFIX_PATH: Directories to be searched by find_package() before its default paths.list(APPEND CMAKE_PREFIX_PATH \"/custom/path\")InstallationCMake provides a flexible install() command that allows you to specify which files should be installed and where they should go. This is useful for deploying your project after it has been built.Basic Install CommandTo install a target, such as a library or an executable, you can use the install() command in your CMakeLists.txt:# Install an executableinstall(TARGETS my_executable DESTINATION bin)# Install a libraryinstall(TARGETS my_library        ARCHIVE DESTINATION lib        LIBRARY DESTINATION lib        RUNTIME DESTINATION bin)Installing Header FilesYou can also install header files using the install() command:install(FILES my_header.h DESTINATION include)Directory InstallationIf you have multiple header files in a directory, you can install them all at once:install(DIRECTORY include/ DESTINATION include)Full Installation ExampleHere’s an example that combines everything:project(MyProject)add_executable(my_executable main.cpp)add_library(my_library STATIC my_library.cpp)install(TARGETS my_executable my_library        RUNTIME DESTINATION bin        LIBRARY DESTINATION lib        ARCHIVE DESTINATION lib)install(FILES my_header.h DESTINATION include)install(DIRECTORY include/ DESTINATION include)Running the Install CommandTo install the targets and files as specified, you can run the following CMake command after building:cmake --install buildThis will copy the built executables, libraries, and header files to the directories specified in your install() commands.By understanding and utilizing these commands and best practices, developers can efficiently manage their C++ projects with CMake, ensuring scalability, maintainability, and cross-platform compatibility."
  },
  
  {
    "title": "The Black Pill (STM32F411CEU6)",
    "url": "/posts/BlackPill-STM32F411CEU6/",
    "categories": "embedded, stm32, STM32F411CEU6",
    "tags": "embedded, STM32, blackpill, STM32F411CEU6, Arm, Cortex_m4",
    "date": "2023-05-17 13:41:00 +0200",
    





    
    "snippet": "              In this article, we will get you started with the STM32F411CE board (aka the black pill). For a complete overview of the board see this.    This chip is based on ARM Cortex-M4 32-Bit ...",
    "content": "              In this article, we will get you started with the STM32F411CE board (aka the black pill). For a complete overview of the board see this.    This chip is based on ARM Cortex-M4 32-Bit Architecture with clock frequency of 100 MHz RAM of 512KB.    This chip is manufactured by the Dutch company STMicroelectronics, which is based in Switzerland. The company provides several tools to develop for their chips. The official IDE is called the STM32CUBE IDE which is used for this quick tutorial.  OverviewThe illustration below demonstrates the characteristics of the pins on the board.Requirements      Development Environment: You can choose either of the following:          STM32Cube IDE:        This is the official STM32 IDE and it includes build environment. you can download it from here.                  CMake and Custom IDE:        Assuming you have CMake installed.                              Download the GNU Arm Embedded Toolchain from here and add it to PATH. This is important to compile the project.                                Download the OpenOCD from here and add it to PATH. This is important for debugging.                                Download the STM32CubeMX from here and add it to PATH. This is important to generate the project files along HAL library.                                    STM32 Cube Programmer: To upload the binary to the chip. You can download it from here.  Project StructureProject Settings (myproject.ioc)This file defines the settings of the chip when it starts, and the necessary code is re-generated whenever this file is updated. From here, you can set the initial mode of the pins (input. output, etc…), Direct Memory Access (DMA) settings, timers and more.Linker Script (STM32F411CEU6_FLASH.ld)Let’s take a look at the linker script generated by STM32 Cube MX:/* Entry Point */ENTRY(Reset_Handler)/* Highest address of the user mode stack */_estack = ORIGIN(RAM) + LENGTH(RAM);    /* end of RAM *//* Generate a link error if heap and stack don't fit into RAM */_Min_Heap_Size = 0x200;      /* required amount of heap  */_Min_Stack_Size = 0x400; /* required amount of stack *//* Specify the memory areas */MEMORY{RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 20KFLASH (rx)     : ORIGIN = 0x08000000, LENGTH = 64K}/* ... */In the linker script (STM32F411CEU6_FLASH.ld), the ENTRY(Reset_Handler) directive specifies this entry point.The Reset_Handler is the entry point for the program and is defined in the assembly file startup_stm32f103xb.s.  It is responsible for initializing the system and preparing the execution environment before jumping to the main application code.  When the microcontroller is reset, the Reset_Handler is the first function that gets executed as specified in the above linker.  This handler is crucial in setting up the system by configuring the stack pointer, initializing data segments, and calling the main() function.Memory LayoutThe memory configuration is defined in the linker script under the MEMORY section. This section specifies the start addresses and lengths of different memory regions in the microcontroller:  RAM: The RAM region is defined with a starting address of 0x20000000 and a length of 20KB. This is the area where the runtime data (variables, stack, and heap) will be stored.  FLASH: The FLASH region, starting at 0x08000000 with a length of 64KB, is used to store the program code and constants.Stack and Heap Configuration      _estack: The _estack symbol defines the highest address of the stack in RAM. It is calculated as the sum of the starting address of RAM (ORIGIN(RAM)) and the total length of RAM (LENGTH(RAM)). This ensures that the stack starts at the end of the available RAM space and grows downwards.        _Min_Heap_Size: This value specifies the minimum required heap size, which is set to 0x200 (512 bytes). The heap is used for dynamic memory allocation during runtime.        _Min_Stack_Size: This value defines the minimum required stack size, set to 0x400 (1024 bytes). The stack is used for storing local variables and function call information during execution.  These values ensure that the heap and stack have enough space within the RAM, preventing overlap and potential runtime errors. The linker script will generate an error if the specified heap and stack sizes do not fit within the defined RAM area.C Entry File (core/Src/main.c)This is the main source code, where the entry function resides. Also, this is place where most of the generated code done by the IDE is written after updating myproject.ioc.We will look into two important functions here.static void MX_GPIO_Init(void);This function sets up the initial settings for the IO pins of the chip. On the board the blue LED is connected to pin C13. If we set this pin mode to GPIO_Output mode in the myproject.ioc file, as in the illustration belowFigure 2: Configuring the chip’s pinswe can see that the IDE has generated the following code in the function MX_GPIO_Init:GPIO_InitTypeDef GPIO_InitStruct = {0};/* GPIO Ports Clock Enable */__HAL_RCC_GPIOC_CLK_ENABLE();/*Configure GPIO pin Output Level */HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);/*Configure GPIO pin : PC13 */GPIO_InitStruct.Pin = GPIO_PIN_13;GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;GPIO_InitStruct.Pull = GPIO_NOPULL;GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct);Lines from 9 to 14 are responsible for initializing the pin C13. We can see in line that the HAL library provides the function HAL_GPIO_Init which takes first the name of the Pins block and then a pointer to a structure GPIO_InitTypeDef. This is also how the pin settings is changed programmatically. The details of the pins settings are explained in the following sub-section.Pin Settings struct: GPIO_InitTypeDefThis C-structure contains five different settings for each pin  Pin  Mode  Pull  Speed  AlternateThe Pin specifies the number of the pin in the Pins block.The Mode specifies the operating mode of the pin. For example, this can be one of the following mode:  Input  Output  Alternate Function  Analog mode  External Interrupt  External EventThe input mode changes a variable variable according to the voltage applied to the pin (Note this should never exceed 3.3V for most pins). To access this input of a pin, we can either access it directly as in the second line, or using the HAL library as in the third line in the code snippet below    uint8_t PA0;    PA0 = GPIOA -&gt; IDR &amp; GPIO_PIN_0;            // directly    PA0 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);  // using HAL LibraryTo set up the pin as input mode, use the definition GPIO_MODE_INPUT.The output mode has two modes itself, these are  Push-Pull  Open-DrainThe push-pull mode sets up the pin for a single direction output. The pin state, can either be high or low. While the open-drain mode, sets up the pin to accept bidirectional input and output. (For more see this article)In the example of the blue LED, the pin mode was set to one direction only since, the pin has apply a voltage to the LED.Tu turn on the blue LED, we need to apply a low voltage at the pin C13 as followsHAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);To set up a pin in an output mode, either use GPIO_MODE_OUTPUT_PP for Push-Pull mode or GPIO_MODE_OUTPUT_OD for open drain mode.Note that the function HAL_GPIO_WritePin writes the value to the pin atomically without ORing it with other masks. That means interrupts do not have to be disabled.The analog mode allows the pin to read the voltage applied to it. However, not all pins are able to be set to this mode, in the case of this chip, these pins are A0..A7 as well as B0 and B1, which also correspond to ADC0..ADC9.Accessing the analog value read from the pin needs additional configuration, such as direct memory access (DMA), which we will look into in the following sections.The rest of the modes are not relevant for this section.The Pull variable specifies which resistors should be connected to the pin. The possible configurations are  Pull down (GPIO_PULLDOWN)  Pull up (GPIO_PULLUP)  No resistor (GPIO_NOPULL)The pull down resistor connects the pin to the ground, while the pull up resistor connects the pin to 3.3V.The Speed variable specifies the frequency at which the pin should operate  GPIO_SPEED_FREQ_LOW ( works at 2MHz )  GPIO_SPEED_FREQ_MEDIUM ( 12.5MHz to 50MHz )  GPIO_SPEED_FREQ_HIGH ( 25MHz to 100MHz )  GPIO_SPEED_FREQ_VERY_HIGH ( 50MHz to 200MHz )General Pin BlocksIn the previous section, we saw how to set up a pin to an push-pull output mode and explored the other modes. Here we will continue to see how to work with the pin blocks, i.e. GPIOA, GPIOB, etc…The C-structure for the Pin Blocks is GPIO_TypeDef. This structure contains the following variables  MODER  OTYPER  OSPEEDER  PUPDR  IDR  ODR  BSRR  LCKR  AFR[2]In the following, we will at some of these registersGPIO Port Mode Register (MODER)This 32-bit register is split into 16 words (two bytes) MODER0..MODER15, each word is responsible to set the mode of the corresponding pin, possible modes are:  00: Input Mode  01: Output Mode  10: Alternate Function  11: Analog ModeGPIO Port Output Type Register (OTYPER)When the mode is set to output mode or alternate function, this register specifies the mode whether push-pull or open-drain (see here).GPIO Input Data Register (IDR)This register is where the values read from input pins are written. (see this)GPIO Output Data Register (ODR)This register is where the values are written into the output pins. It is not recommended to use this register to write to selected pin of the port, use rather the BSRR instead, since this register writes to the whole port. That means writing to a pin requires multiple operations, while the BSRR provides atomic operations to write to a single pin.GPIO Port Bit Set/Reset Register (BSRR)This register is used to atomically write to an output pin. It is used this wayGPIOA -&gt; BSSR = (uint32_t)GPIO_PIN_0 &lt;&lt; 16U;But this is exactly what HAL libary’s function HAL_GPIO_WritePin does. Hence, there is no need to access it directly for most cases.Pulse-Width-Modulation (PWM)The STM32Cube IDE sets this easily, from the file myproject.ioc, first go to System Core, then click on RCC. Set both High and Low Clocks speeds to Crystal/Ceramic Resonator. Then go to Tim3 Peripheral in Timers. The timer 3 has four channels, we activate the first channel by setting it to “PWM Generation CH1”.The frequency of the PWM is defined byfPWM=fAPB Timer Clock(ARR+1)⋅(PSC+1)fPWM=fAPB Timer Clock(ARR+1)⋅(PSC+1)Here, ARR is the Auto-reload register, which defines the counter period. PSC is the pre-scaler. Note that both ARR and PSC registers contain the corresponding values minus one.The Duty is defined byDuty=CCRARR[%]Duty=CCRARR[%]Here CCR is the capture compare register.These registers can be set in the “Parameter Settings” window by their names.This generates a private variable “htim3” in main.c. This is the handler of the timer. To initialize the timer, we need to call the following functionHAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_1);And this will get the PWM working.Setting up the Clock FrequencyFrom myproject.ioc click on the tab “Clock Configuration”, you should see the following screenFigure 3: Screenshot of the Clock ConfigurationThe clock speed is the HCLK register. Now we will configure the clock depending on the chip. For instance, the black pill STM32F411CEUx from WeAct is connected to a 32.786KHz resonator on the LSE and 25MHz on the HSE. Therefore, it has to be set up as in Figure 3 to clock it up to 100MHz.However, sometimes certain services require a certain clock speeds, as explained in the next section.Serial ConnectionHere, we will explain the service “universal serial bus on-the-go full speed” (USB OTG FS) which is compliant with USB 2.0. This service requires a dedicated 48MHz clock connected to the HSE oscillator. (see datasheet 3.27)Figure 4: Screenshot of the Clock configured for the USB_OTG_FS serviceAfter having configured the APB1 peripheral clock to run at 48MHz, we should  In the Connectivity, USB_OTG_FS configuration set the mode to “Device Only”. This activates the middleware “USB_DEVICE” in the “Middleware” category.  Go to Middleware, USB_DEVICE and set the class to be “Communication Device Class (Virtual Port Com)”.  Now in the configuration, you can change the “PRODUCT_String” among other settings.Notes– The “USB_DEVICE” middleware uses another middleware which is STM32USB_DEVICE Library, which uses the “usb_core” from it.– The “usb_core” controls the important parts of the USB device but not the communication– From “USB_DEVICE”, the core is stored in the _usb_device.c– The description (vendor, product, ..) is stored in usbd_desc.c– The functionality to send and receive data are in usb_cdc_if.c, which is what we need to edit."
  },
  
  {
    "title": "Jekyll Chirpy Tester",
    "url": "/posts/Tester/",
    "categories": "Web, Jekyll",
    "tags": "",
    "date": "2023-05-16 13:41:00 +0200",
    





    
    "snippet": "Code    uint8_t PA0;    PA0 = GPIOA -&gt; IDR &amp; GPIO_PIN_0;            // directly    PA0 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);  // using HAL Library    #include &lt;iostream&gt;int main(int a...",
    "content": "Code    uint8_t PA0;    PA0 = GPIOA -&gt; IDR &amp; GPIO_PIN_0;            // directly    PA0 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);  // using HAL Library    #include &lt;iostream&gt;int main(int argc, char *argv[]) {  /* An annoying \"Hello World\" example */  for (auto i = 0; i &lt; 0xFFFF; i++)    cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl;  char c = '\\n';  unordered_map &lt;string, vector&lt;string&gt; &gt; m;  m[\"key\"] = \"\\\\\\\\\"; // this is an error  return -2e3 + 12l;  GPIO_InitStruct.Pin = GPIO_PIN_13;GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;GPIO_InitStruct.Pull = GPIO_NOPULL;GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct);}uint8_t PA0;PA0 = GPIOA -&gt; IDR &amp; GPIO_PIN_0;            // directlyPA0 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);  // using HAL Library#include &lt;iostream&gt;int main(int argc, char *argv[]) {  /* An annoying \"Hello World\" example */  for (auto i = 0; i &lt; 0xFFFF; i++)    cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl;  char c = '\\n';  unordered_map &lt;string, vector&lt;string&gt; &gt; m;  m[\"key\"] = \"\\\\\\\\\"; // this is an error  return -2e3 + 12l;}Callouts  Here are multiple items      item 1    item 2              item 2.1              Here are multiple items      item 1    item 2              item 2.1              This is a danger alert—be cautious!    This is a warning alert—attention needed!    d  This is an informational alert—take note!"
  }
  
]

