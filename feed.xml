<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-09-05T18:31:08+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Mustafa Alotbah’s Blog</title><subtitle>Welcome to a space dedicated to exploring computer science and data science.  Here, you&apos;ll find insights on machine learning, simulation projects, and embedded systems.  Whether you&apos;re a student, professional, or tech enthusiast, this blog offers ideas and projects to inspire and inform as we navigate the evolving world of technology together.</subtitle><entry><title type="html">C++20 - Coroutines</title><link href="http://localhost:4000/posts/CPP-Coroutines/" rel="alternate" type="text/html" title="C++20 - Coroutines" /><published>2024-01-22T21:34:00+01:00</published><updated>2024-01-22T21:34:00+01:00</updated><id>http://localhost:4000/posts/CPP-Coroutines</id><content type="html" xml:base="http://localhost:4000/posts/CPP-Coroutines/"><![CDATA[<p>Coroutines, introduced in C++20, bring a powerful mechanism for handling asynchronous operations, generators and cooperative multitasking.
Unlike conventional functions, which execute sequentially from start to return, coroutines are functions that can suspend and resume execution at specific points, effectively allowing you to pause execution, yield results, and return control to the caller without fully exiting the function.</p>

<h2 id="introduction">Introduction</h2>

<p>At their core, coroutines empower <em>cooperative multitasking</em> by enabling a function to be <em>suspended</em> and later <em>resumed</em> without losing its state.
This is in contrast to <em>preemptive multitasking</em>—such as that implemented with threads—where the operating system arbitrarily decides when to suspend a task and switch context.
Coroutines, by contrast, give the programmer explicit control over when and where to suspend or resume execution, making them a lighter and more efficient alternative for certain asynchronous programming patterns.</p>

<p>When a coroutine is called, it doesn’t run to completion immediately. Instead, it returns a special object, typically referred to as a <em>coroutine handle</em>, which the caller can use to resume or finalize the coroutine’s execution. This behavior introduces a level of flexibility and control that traditional functions simply do not possess.</p>

<p>Coroutines can be applied across a wide range of use cases, including:</p>

<ul>
  <li>
    <p><strong>Asynchronous I/O</strong>:</p>

    <p>Efficiently suspending operations until data becomes available from a network or file system, avoiding costly thread blocking.</p>
  </li>
  <li>
    <p><strong>Event-driven systems</strong>:</p>

    <p>Enabling highly responsive applications by reacting to incoming events without halting the system, while simultaneously maintaining clarity in control flow.</p>
  </li>
  <li>
    <p><strong>Lazy data generation</strong>:</p>

    <p>Producing data incrementally, without needing to allocate or compute the entire sequence at once, thus optimizing memory and computation resources.</p>
  </li>
</ul>

<h2 id="objective">Objective</h2>

<p>In this article, we will implement a simple generator-like coroutine that produces a sequence of integers, yielding values incrementally as they are requested. Consider the following example:</p>

<pre><code class="language-cpp">int main() {

    // Create the coroutine to count from 1 to 5
    Generator counter = simple_counter(1, 5);  

    // Iterate through the yielded values
    while (counter.next()) {

        // Output each yielded value
        std::cout &lt;&lt; counter.get() &lt;&lt; " ";  
    }

    std::cout &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>The expected output for this program would be:</p>

<pre><code class="language-txt">1 2 3 4 5
</code></pre>

<p>The primary coroutine function we aim to implement is a generator that yields consecutive integers between a given start and end value:</p>

<pre><code class="language-cpp">// Coroutine function that yields consecutive numbers
Generator simple_counter(int start, int end) {
    for (int i = start; i &lt;= end; ++i) {
        // yield the current value
        co_yield i;
    }
}
</code></pre>

<p>In the code above, <code class="language-plaintext highlighter-rouge">co_yield</code> is the key operator introduced by C++20 coroutines. When encountered, it pauses the execution of the coroutine and returns a value to the caller. The coroutine can then be resumed from this point, maintaining the state of local variables.</p>

<p>Let’s break down the essential components involved in making this coroutine functional and efficient in C++20.</p>

<h2 id="formal-definition">Formal Definition</h2>

<p>In C++20, coroutines are implemented under the hood as a <strong>finite state machine (FSM)</strong>—a widely-recognized computational model where the system resides in one of a finite number of states at any given time and transitions between states occur based on events. For coroutines, these transitions involve saving the current state of execution and potentially performing actions such as yielding a value or suspending execution. This FSM model is particularly well-suited for coroutines, as they are designed to pause, yield results, and resume at precise points during their execution.</p>

<p>A coroutine’s state persists across suspension points, enabling the function to resume from exactly where it was last paused upon the next invocation. Control over these state transitions in C++20 coroutines is achieved through three key operations:</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">co_yield</code></strong>:</p>

    <p>The <code class="language-plaintext highlighter-rouge">co_yield</code> operator suspends the coroutine while yielding a value back to the caller. It also allows a coroutine to generate a sequence of values over multiple suspensions, maintaining its state between yields. This makes it highly suitable for generator-style coroutines, where values are produced incrementally.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">co_return</code></strong>:</p>

    <p>The <code class="language-plaintext highlighter-rouge">co_return</code> statement signals the completion of the coroutine, returning a final value. Once a coroutine encounters <code class="language-plaintext highlighter-rouge">co_return</code>, it cannot be resumed, and the coroutine’s lifetime ends.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">co_await</code></strong>:</p>

    <p>The <code class="language-plaintext highlighter-rouge">co_await</code> operator suspends the coroutine, handing control back to the caller, until a specific condition—typically represented as an asynchronous event—is met. When the awaited condition is fulfilled, the coroutine resumes execution at the point where it was suspended. The type of object that is awaited must conform to the <strong>Awaitable</strong> concept, which means it must provide the following methods:</p>

    <ol>
      <li><code class="language-plaintext highlighter-rouge">await_ready()</code>: Determines if the operation is ready to proceed or if it needs to suspend.</li>
      <li><code class="language-plaintext highlighter-rouge">await_suspend()</code>: Suspends the coroutine and potentially schedules it to be resumed later.</li>
    </ol>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">await_resume()</code>: Returns the result of the awaited operation when the coroutine is resumed.</p>
  </li>
</ul>

<h3 id="state-transitions-in-coroutines">State Transitions in Coroutines</h3>

<p>The execution of a coroutine is driven by state transitions, which are managed by the <code class="language-plaintext highlighter-rouge">co_await</code>, <code class="language-plaintext highlighter-rouge">co_yield</code>, and <code class="language-plaintext highlighter-rouge">co_return</code> operations. These transitions occur between the following states:</p>

<ol>
  <li>
    <p><strong>Initial State</strong>:
 When a coroutine is first called, it enters the initial state. At this point, the function <code class="language-plaintext highlighter-rouge">promise_type::initial_suspend()</code> decides whether the coroutine should immediately suspend or continue execution. This gives the developer control over whether the coroutine begins running immediately or waits to be explicitly resumed.</p>
  </li>
  <li>
    <p><strong>Running State</strong>:<br />
 Once execution begins, the coroutine proceeds normally until it encounters a suspension point, such as a <code class="language-plaintext highlighter-rouge">co_await</code> or <code class="language-plaintext highlighter-rouge">co_yield</code>. Upon reaching these points, it returns control to the caller and moves into the suspended state.</p>
  </li>
  <li>
    <p><strong>Suspended State</strong>:<br />
 While suspended, the coroutine’s execution context—including its local variables and call stack—is preserved. At any point, the coroutine can be resumed, at which point it continues execution from the last suspension point, progressing toward its next suspension or completion.</p>
  </li>
  <li>
    <p><strong>Final State</strong>:<br />
 After the coroutine encounters a <code class="language-plaintext highlighter-rouge">co_return</code>, it enters the final state, indicating the completion of its execution. The function <code class="language-plaintext highlighter-rouge">promise_type::final_suspend()</code> ensures that no further actions can be taken on the coroutine once it has reached this point, allowing for proper cleanup and termination.</p>
  </li>
</ol>

<p>These operations and state transitions make it easier to manage asynchronous workflows, allowing for clear and efficient state management while maintaining a straightforward control flow. By combining these with custom <code class="language-plaintext highlighter-rouge">promise_type</code> objects and <code class="language-plaintext highlighter-rouge">awaitable</code> objects, C++20 coroutines offer a powerful abstraction for managing both synchronous and asynchronous tasks.</p>

<h3 id="lifecycle-of-a-coroutine">Lifecycle of a Coroutine</h3>

<p>The lifecycle of a coroutine is intricately managed by these state transitions. The following diagram captures the transitions and operations:</p>

<pre><code class="language-mermaid">stateDiagram-v2
    %% Starting point
    [*] --&gt; InitialState
    InitialState: Initial State

    %% Transition to Running or Suspended State based on initial_suspend()
    InitialState --&gt; RunningState: coroutine called
    InitialState --&gt; SuspendedState: initial_suspend()

    %% Running State
    RunningState: Running State
    RunningState --&gt; SuspendedState: co_await / co_yield
    RunningState --&gt; FinalState: co_return

    %% Suspended State
    SuspendedState: Suspended State
    SuspendedState --&gt; RunningState: resume()
    SuspendedState --&gt; FinalState: co_return / Scope End

    %% Final State
    FinalState: Final State
    FinalState: final_suspend()
</code></pre>

<p>By explicitly controlling state transitions, C++20 coroutines provide a structured, efficient mechanism for managing asynchronous workflows. Unlike traditional multithreading, where the operating system handles preemptive task switching, coroutines give the programmer direct control over suspensions and resumptions, leading to a more predictable and performant system. Moreover, the use of <code class="language-plaintext highlighter-rouge">promise_type</code> and <code class="language-plaintext highlighter-rouge">awaitable</code> objects allows developers to customize the behavior of coroutines, providing fine-grained control over both synchronous and asynchronous tasks.</p>

<h2 id="implementing-the-coroutine">Implementing the Coroutine</h2>

<p>In order to employ the <code class="language-plaintext highlighter-rouge">co_yield</code> operator within a function, the return type must conform to the <strong>coroutine</strong> <strong>concept</strong> as defined by the C++20 standard. When the compiler detects the presence of keywords like <code class="language-plaintext highlighter-rouge">co_yield</code>, <code class="language-plaintext highlighter-rouge">co_await</code>, or <code class="language-plaintext highlighter-rouge">co_return</code>, it automatically flags the function as a coroutine, which fundamentally changes its behavior.</p>

<p>Instead of following the conventional function model of entering, executing, and exiting, coroutines return an intermediate object (e.g. <code class="language-plaintext highlighter-rouge">Generator</code>) that encapsulates their state and enables suspension and resumption of execution. This returned object serves as the interface through which the coroutine interacts with the calling environment.</p>

<p>In our example, the coroutine will return an object of type <code class="language-plaintext highlighter-rouge">Generator</code>, which will function as a generator of integers. To fulfill the coroutine’s requirements and the compiler’s expectations, we need to define a corresponding generator class, <code class="language-plaintext highlighter-rouge">Generator</code>, that adheres to the coroutine concept. At the core of this concept lies the <code class="language-plaintext highlighter-rouge">promise_type</code>, a structure that mediates between the caller and the coroutine, orchestrating the coroutine’s lifecycle, including suspension, resumption, and finalization.</p>

<p>Below is the skeletal structure of our generator <code class="language-plaintext highlighter-rouge">Generator</code>, which we will expand to implement the necessary coroutine mechanisms:</p>

<pre><code class="language-cpp">class Generator {
    // Required by the compiler to control the coroutine
    struct promise_type;  

    // constructor
    Generator(std::coroutine_handle&lt;promise_type&gt; handle);   

private: 
    // Handle to control coroutine execution
    std::coroutine_handle&lt;promise_type&gt; coroutine_handle_; 
}
</code></pre>

<h3 id="the-heart-of-coroutines-promise_type">The Heart of Coroutines: promise_type</h3>

<p>The <code class="language-plaintext highlighter-rouge">promise_type</code> structure is the core component in C++20 coroutines, responsible for managing the coroutine’s internal state and interacting with the calling code. Whenever a coroutine is invoked, the compiler generates an instance of the <code class="language-plaintext highlighter-rouge">promise_type</code>. The <code class="language-plaintext highlighter-rouge">promise_type</code> interface defines how the coroutine behaves at each phase of its execution, including initial suspension, resumption, final suspension, and error handling.</p>

<p>The <code class="language-plaintext highlighter-rouge">promise_type</code> must provide the following methods to manage coroutine state transitions:</p>

<pre><code class="language-cpp">struct promise_type {
    // Returns the object that the coroutine will hand back to the caller
    Generator get_return_object();

    // Suspend execution immediately after starting
    std::suspend_always initial_suspend();

    // Suspend execution after the coroutine is done
    std::suspend_always final_suspend() noexcept;

    // Handle any exceptions that occur within the coroutine
    void unhandled_exception();
};
</code></pre>

<p>Key methods that must be implemented in <code class="language-plaintext highlighter-rouge">promise_type</code> include:</p>

<ul>
  <li>
    <ol>
      <li><strong><code class="language-plaintext highlighter-rouge">Generator get_return_object()</code></strong>:<br />
  This method returns the object that will represent the coroutine’s execution state to the caller. It is called as soon as the coroutine is instantiated. In the case of a generator, it returns a handle to the coroutine itself, allowing the caller to resume or query the coroutine’s state.</li>
    </ol>

    <p>The typical implementation for this method is as follows:</p>

    <pre><code class="language-cpp">  Generator Generator::promise_type::get_return_object()  
  {
      // The coroutine_handle manages the lifetime and resumption of the coroutine
      return Generator{std::coroutine_handle&lt;promise_type&gt;::from_promise(*this)};  
  }
</code></pre>

    <p>Here, the <code class="language-plaintext highlighter-rouge">from_promise()</code> function creates a coroutine handle that ties the <code class="language-plaintext highlighter-rouge">promise_type</code> to the coroutine object, providing the caller with full control over the coroutine’s lifecycle.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::suspend_always initial_suspend()</code></strong>:<br />
  This method determines whether the coroutine should suspend execution immediately upon creation. The return type must satisfy the <strong>awaitable</strong> concept, which determines how the coroutine behaves at suspension points. Returning <code class="language-plaintext highlighter-rouge">std::suspend_always</code> ensures that the coroutine will suspend after being invoked, giving the caller control over when to resume execution.</p>

    <p>Example implementation:</p>

    <pre><code class="language-cpp">  std::suspend_always Generator::promise_type::initial_suspend()  
  {  
      // The coroutine starts in a suspended state and must be resumed explicitly
      return {};  
  }
</code></pre>

    <p>In this case, we return <code class="language-plaintext highlighter-rouge">std::suspend_always</code>, indicating that the coroutine suspends right after its invocation, awaiting an explicit resume action.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::suspend_always final_suspend()</code></strong>:<br />
  This method is called when the coroutine reaches its end, either through a <code class="language-plaintext highlighter-rouge">co_return</code> or because the function runs to completion. It determines whether the coroutine should suspend before final cleanup or exit immediately. The typical pattern is to use <code class="language-plaintext highlighter-rouge">std::suspend_always</code> to ensure that the caller has an opportunity to finalize any resources tied to the coroutine handle.</p>

    <p>Example:</p>

    <pre><code class="language-cpp">  std::suspend_always Generator::promise_type::final_suspend()  
  {  
      // After the coroutine is done, it suspends one last time before being destroyed
      return {};  
  }
</code></pre>

    <p>This final suspension is a key point in the coroutine’s lifecycle, giving the caller a chance to perform any necessary cleanup or synchronizing actions.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">void unhandled_exception()</code></p>

    <p>This method defines the coroutine’s behavior when an exception is thrown inside the coroutine body and not explicitly handled. The most common implementation involves terminating the program, but more advanced handlers could log the error or propagate the exception to the caller.</p>

    <p>Example implementation:</p>

    <pre><code class="language-cpp">  void Generator::promise_type::unhandled_exception()  
  {  
      // Terminate the program or just log an error and freeze the coroutine
      std::terminate();  
  }
</code></pre>

    <p>In this basic implementation, <code class="language-plaintext highlighter-rouge">std::terminate()</code> is called to halt the program when an unhandled exception occurs within the coroutine. More advanced coroutine systems may instead propagate exceptions back to the caller.</p>
  </li>
</ul>

<h3 id="the-awaitable-concept">The Awaitable Concept</h3>

<p>The <strong>awaitable</strong> concept in C++ defines a set of rules for objects that can be used in conjunction with <code class="language-plaintext highlighter-rouge">co_await</code>. These objects determine whether a coroutine should suspend, what happens when it suspends, and how the coroutine resumes. In the context of coroutines, both <code class="language-plaintext highlighter-rouge">std::suspend_always</code> and <code class="language-plaintext highlighter-rouge">std::suspend_never</code> are common awaitables that provide predefined behavior for suspension.</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::suspend_always</code></strong>:<br />
  This is an awaitable that always suspends the coroutine. It is used when the coroutine should explicitly suspend, allowing the caller to determine when to resume it.</p>

    <pre><code class="language-cpp">  struct std::suspend_always {
      bool await_ready() const noexcept { return false; }
      void await_suspend(std::coroutine_handle&lt;&gt;) const noexcept {}
      void await_resume() const noexcept {}
  };
</code></pre>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">await_ready()</code>: Returns <code class="language-plaintext highlighter-rouge">false</code>, indicating that the coroutine should suspend.</li>
      <li><code class="language-plaintext highlighter-rouge">await_suspend()</code>: Performs the actual suspension.</li>
      <li><code class="language-plaintext highlighter-rouge">await_resume()</code>: Defines what happens when the coroutine resumes.</li>
    </ul>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::suspend_never</code></strong>:<br />
  This awaitable ensures that the coroutine never suspends at a particular suspension point, allowing it to continue execution without interruption.</p>

    <pre><code class="language-cpp">  struct std::suspend_never {
      bool await_ready() const noexcept { return true; }
      void await_suspend(std::coroutine_handle&lt;&gt;) const noexcept {}
      void await_resume() const noexcept {}
  };
</code></pre>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">await_ready()</code>: Returns <code class="language-plaintext highlighter-rouge">true</code>, meaning the coroutine does not suspend.</li>
      <li><code class="language-plaintext highlighter-rouge">await_suspend()</code> and <code class="language-plaintext highlighter-rouge">await_resume()</code> are no-ops, as no suspension occurs.</li>
    </ul>
  </li>
</ul>

<h3 id="coroutine-operators">Coroutine Operators</h3>

<p>In C++20, coroutines utilize specialized operators (<code class="language-plaintext highlighter-rouge">co_await</code>, <code class="language-plaintext highlighter-rouge">co_yield</code>, and <code class="language-plaintext highlighter-rouge">co_return</code>) to manage control flow, yielding values, awaiting asynchronous events, or signaling coroutine completion. For a coroutine to function correctly, it must overload and implement at least one of these operators. The choice of the operator depends on the desired behavior—whether the coroutine should suspend while awaiting, yield intermediate results, or complete execution and return a value.</p>

<h4 id="the-operator-co_yield">The Operator co_yield</h4>

<p>The <code class="language-plaintext highlighter-rouge">co_yield</code> operator facilitates the suspension of the coroutine, returning control to the caller while also passing back a value.
To overload this operator, the <code class="language-plaintext highlighter-rouge">promise_type</code> structure must implement at least one of two forms of <code class="language-plaintext highlighter-rouge">yield_value</code>:  <code class="language-plaintext highlighter-rouge">awaitable yield_value(T)</code> or <code class="language-plaintext highlighter-rouge">awaitable yield_void()</code>.</p>

<pre><code class="language-cpp">struct promise_type {
    Generator get_return_object();
    std::suspend_always initial_suspend();
    std::suspend_always final_suspend() noexcept;
    void unhandled_exception();

    // Overload for yielding an integer value (e.g., `co_yield 5;`)
    std::suspend_always yield_value(int val);

    // Overload for yielding a string value (e.g., `co_yield "Hello";`)
    std::suspend_always yield_value(std::string val);

    // Yielding control without passing a value (e.g., `co_yield;`)
    std::suspend_always yield_void();
};
</code></pre>

<p>In the context of a generator design like <code class="language-plaintext highlighter-rouge">Generator</code>, the <code class="language-plaintext highlighter-rouge">yield_value</code> function is used to store or update the coroutine’s internal state (<code class="language-plaintext highlighter-rouge">current_value</code>), which the user can later retrieve. However, coroutines are much more powerful and can solve more complex control flow problems than simple generators.</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">awaitable yield_value(T)</code></strong>:</p>

    <p>This method is invoked when <code class="language-plaintext highlighter-rouge">co_yield</code> is used in the coroutine. It suspends the coroutine and yields the value <code class="language-plaintext highlighter-rouge">T</code> to the caller. At this suspension point, the state of the coroutine is preserved, allowing it to resume at a later time. The caller can retrieve the yielded value after resumption.</p>

    <p>Example implementation:</p>

    <pre><code class="language-cpp">  std::suspend_always promise_type::yield_value(int value) {
      value_ = value;  // Store the yielded value in the internal state
      return {};       // Suspend the coroutine
  }
</code></pre>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">awaitable yield_void()</code></strong>:</p>

    <p>This method is called when the coroutine is suspended without yielding a specific value to the caller. It can be used when the coroutine needs to pause execution but doesn’t produce an output. This operator is less common in generator-style coroutines but can be useful in control flow scenarios.</p>

    <p>Example:</p>

    <pre><code class="language-cpp">  std::suspend_always promise_type::yield_void() {
      // Suspend the coroutine without yielding a value
      return {};
  }
</code></pre>
  </li>
</ul>

<p>Hence for our <code class="language-plaintext highlighter-rouge">Generator</code> example, we could define</p>

<pre><code class="language-cpp">class Generator  
{  
 public:
    struct promise_type  
    { 
     public:  
        Generator get_return_object();  
        std::suspend_always initial_suspend();  
        std::suspend_always final_suspend() noexcept;   
        void unhandled_exception();  
    
        // Overload co_yield, 
        std::suspend_always yield_value(int val);
     public:
        friend class Generator;
        int value_{ 0 };  
    };

    // type alias to reduce code
    using handle_type = std::coroutine_handle&lt;promise_type&gt;;  

private:
    handle_type coroutine_handle_;
}
</code></pre>

<h4 id="the-operator-co_return">The Operator co_return</h4>

<p>The <code class="language-plaintext highlighter-rouge">co_return</code> operator signals the end of a coroutine and allows the coroutine to return a value to the caller. The <code class="language-plaintext highlighter-rouge">promise_type</code> must implement <code class="language-plaintext highlighter-rouge">return_value(T)</code> or <code class="language-plaintext highlighter-rouge">return_void()</code> to overload this operator.</p>

<p>Example:</p>

<pre><code class="language-cpp">struct promise_type {
    Generator get_return_object();
    std::suspend_always initial_suspend();
    std::suspend_always final_suspend() noexcept;
    void unhandled_exception();

    // Return an integer value upon coroutine completion (e.g., `co_return 42;`)
    std::suspend_always return_value(int val);

    // Return a string upon coroutine completion (e.g., `co_return "Done";`)
    std::suspend_always return_value(std::string val);

    // Signal coroutine completion without returning a value (e.g., `co_return;`)
    std::suspend_always return_void();
};
</code></pre>

<p>In the <code class="language-plaintext highlighter-rouge">Generator</code> example, we could overload the <code class="language-plaintext highlighter-rouge">return_value</code> and <code class="language-plaintext highlighter-rouge">return_void</code> operators to handle final results or simply to indicate that the coroutine has completed its execution.</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">awaitable return_value(T)</code></strong>:</p>

    <p>This method is called when <code class="language-plaintext highlighter-rouge">co_return</code> is used in the coroutine, allowing the coroutine to return a final value to the caller. It suspends the coroutine, signals completion, and passes the return value back to the caller.</p>

    <pre><code class="language-cpp">  std::suspend_always Generator::promise_type::return_value(int val) {
      value_ = val;  // Store the final returned value
      return {};     // Suspend the coroutine before finalization
  }
</code></pre>

    <p>In this example, the <code class="language-plaintext highlighter-rouge">return_value</code> method stores the value passed to <code class="language-plaintext highlighter-rouge">co_return</code> in the <code class="language-plaintext highlighter-rouge">value_</code> field of the <code class="language-plaintext highlighter-rouge">promise_type</code>. The coroutine is then suspended one last time, allowing the caller to retrieve the value before the coroutine is destroyed.</p>

    <p>Usage in a coroutine:</p>

    <pre><code class="language-cpp">  Generator simple_counter(int start, int end) {
      for (int i = start; i &lt;= end; ++i) {
          co_yield i;
      }
      // Return a final result after the loop completes
      co_return end + 1;  
  }
</code></pre>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">awaitable return_void()</code></strong>:</p>

    <p>This method is invoked when <code class="language-plaintext highlighter-rouge">co_return</code> is used without a value, simply marking the coroutine as complete and suspending it for final cleanup. This is useful when the coroutine’s task is done, and no final value needs to be returned. After calling <code class="language-plaintext highlighter-rouge">return_void()</code>, the coroutine transitions to its final suspended state and is then cleaned up.</p>

    <pre><code class="language-cpp">  std::suspend_always promise_type::yield_void() {
      // Suspend the coroutine without yielding a value
      return {};
  }
</code></pre>

    <p>In this case, the coroutine finishes without yielding or returning any specific value. The final suspension allows the coroutine’s resources to be cleaned up in an orderly fashion.</p>

    <p>Usage in a coroutine:</p>

    <pre><code class="language-cpp">  Generator simple_counter(int start, int end) {
      for (int i = start; i &lt;= end; ++i) {
          co_yield i;
      }
      // End the coroutine without returning a value
      co_return;
  }
</code></pre>
  </li>
</ul>

<h3 id="managing-the-coroutine-handle">Managing the Coroutine Handle</h3>

<p>In the above implementation, we leverage <code class="language-plaintext highlighter-rouge">std::coroutine_handle</code> to manage the lifecycle of the coroutine. This handle acts as a lightweight wrapper that directly interfaces with the coroutine, allowing control over its execution. The handle is essential for interacting with the coroutine at various stages—suspension, resumption, finalization, and cleanup.</p>

<p>Here is a more detailed explanation of the key functions of <code class="language-plaintext highlighter-rouge">std::coroutine_handle</code> utilized in our <code class="language-plaintext highlighter-rouge">Generator</code> example:</p>

<ol>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">void destroy()</code></strong>:<br />
 The <code class="language-plaintext highlighter-rouge">destroy()</code> method is used to explicitly destroy the coroutine. It ensures that once the coroutine has completed its execution, its resources are properly cleaned up, preventing memory leaks. In our <code class="language-plaintext highlighter-rouge">Generator</code> class, we call <code class="language-plaintext highlighter-rouge">destroy()</code> within the destructor, ensuring that if the coroutine is still alive, it gets terminated and cleaned up before the <code class="language-plaintext highlighter-rouge">Generator</code> object goes out of scope.</p>

    <p>Example usage in the destructor:</p>

    <pre><code class="language-cpp"> Generator::~Generator() {
     // Clean up coroutine resources
     if (coroutine_handle_) coroutine_handle_.destroy();  
 }
</code></pre>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">void resume()</code></strong>:<br />
 The <code class="language-plaintext highlighter-rouge">resume()</code> method allows the coroutine to proceed from its last suspension point. This is used within the <code class="language-plaintext highlighter-rouge">next()</code> function, which resumes the coroutine and attempts to move it to the next <code class="language-plaintext highlighter-rouge">co_yield</code> or <code class="language-plaintext highlighter-rouge">co_return</code>. By invoking <code class="language-plaintext highlighter-rouge">resume()</code>, the coroutine’s execution is continued until it either reaches another suspension point or completes execution.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">bool done()</code></strong>:<br />
 The <code class="language-plaintext highlighter-rouge">done()</code> method checks whether the coroutine has reached its final state and is no longer resumable. It returns <code class="language-plaintext highlighter-rouge">true</code> if the coroutine has completed execution. This is important for ensuring that the coroutine is not resumed after it has finished. In the <code class="language-plaintext highlighter-rouge">next()</code> function, <code class="language-plaintext highlighter-rouge">done()</code> is checked both before and after calling <code class="language-plaintext highlighter-rouge">resume()</code> to ensure that the coroutine is still active.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">promise_type&amp; promise()</code></strong>:<br />
 The <code class="language-plaintext highlighter-rouge">promise()</code> method provides access to the <code class="language-plaintext highlighter-rouge">promise_type</code> instance associated with the coroutine. This is crucial because the <code class="language-plaintext highlighter-rouge">promise_type</code> holds the internal state of the coroutine, including the value that was last yielded or returned. The <code class="language-plaintext highlighter-rouge">promise()</code> method is used in the <code class="language-plaintext highlighter-rouge">get()</code> function to retrieve the current value yielded by the coroutine.</p>
  </li>
</ol>

<h3 id="retrieving-values-in-the-generator">Retrieving Values in the Generator</h3>

<p>To allow interaction between the <code class="language-plaintext highlighter-rouge">Generator</code> generator and the caller, we need two essential methods:</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">bool next()</code></strong>: This method continues the execution of the coroutine until it suspends again, either due to a <code class="language-plaintext highlighter-rouge">co_yield</code> or <code class="language-plaintext highlighter-rouge">co_return</code>. It checks if the coroutine is done, resumes execution, and returns whether the coroutine has yielded a new value. If the coroutine has completed execution, it returns <code class="language-plaintext highlighter-rouge">false</code>.</p>

    <p>Full implementation:</p>

    <pre><code class="language-cpp">  bool Generator::next() const  
  {  
     if (!coroutine_handle_ || coroutine_handle_.done()) return false;  

     // Resume the coroutine  
     coroutine_handle_.resume();  

     // Check again if it's done after resuming  
     return !coroutine_handle_.done();
  }
</code></pre>

    <p>Before resuming the coroutine, we first ensure that the coroutine handle is properly initialized and that the coroutine has not already completed its execution. This is accomplished by checking if the handle is valid and if the coroutine is not in the <em>done</em> state.</p>

    <p>Once confirmed, we can safely invoke the <code class="language-plaintext highlighter-rouge">resume()</code> method to move the coroutine forward to its next suspension point. The use of <code class="language-plaintext highlighter-rouge">co_yield</code> within the coroutine may return a value and suspend execution at multiple points before the function fully completes. After calling <code class="language-plaintext highlighter-rouge">resume()</code>, it is essential to check again whether the coroutine has reached its final state by invoking <code class="language-plaintext highlighter-rouge">done()</code>.</p>

    <p>If the resumption of the coroutine leads to its termination without yielding any additional values, we return <code class="language-plaintext highlighter-rouge">false</code>, indicating that the coroutine has completed its task. This prevents further attempts to resume a completed coroutine.</p>

    <p>However, if we employ <code class="language-plaintext highlighter-rouge">co_return</code> at the end of the coroutine, and it results in a final value being returned, we would return <code class="language-plaintext highlighter-rouge">true</code>, as this indicates that the coroutine has successfully yielded a value before reaching its conclusion. In this case, the caller can retrieve the final value using the <code class="language-plaintext highlighter-rouge">get()</code> method.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">int get()</code></strong>: This method retrieves the current value yielded by the coroutine. It accesses the <code class="language-plaintext highlighter-rouge">promise_type</code> through the coroutine handle to fetch the stored value. This method should be called after <code class="language-plaintext highlighter-rouge">next()</code> returns <code class="language-plaintext highlighter-rouge">true</code>, indicating that the coroutine has successfully yielded a new value.
  Full implementation:</p>

    <pre><code class="language-cpp">  int Generator::get() const  
  {  
      return coroutine_handle_.promise().value_;  
  }
</code></pre>

    <p>Here, the method accesses the <code class="language-plaintext highlighter-rouge">promise_type</code> instance via the <code class="language-plaintext highlighter-rouge">coroutine_handle_</code>, fetching the <code class="language-plaintext highlighter-rouge">value_</code> field, which stores the value yielded during the last <code class="language-plaintext highlighter-rouge">co_yield</code> or <code class="language-plaintext highlighter-rouge">co_return</code>.</p>
  </li>
</ul>

<!-- TODO: co_wait, unhandled_exception, Asynchronous Example, Event-based systems -->]]></content><author><name></name></author><category term="Software-Development" /><category term="C++" /><category term="Software" /><category term="C++" /><category term="C++20" /><category term="Software" /><category term="Designs" /><category term="Generator" /><category term="Coroutine" /><summary type="html"><![CDATA[Coroutines, introduced in C++20, bring a powerful mechanism for handling asynchronous operations, generators and cooperative multitasking. Unlike conventional functions, which execute sequentially from start to return, coroutines are functions that can suspend and resume execution at specific points, effectively allowing you to pause execution, yield results, and return control to the caller without fully exiting the function.]]></summary></entry><entry><title type="html">Efficient Exception Handling in Resource-Constrained Embedded Systems</title><link href="http://localhost:4000/posts/Exploring-Exception-Handling-Mechanisms-in-Embedded-Environments/" rel="alternate" type="text/html" title="Efficient Exception Handling in Resource-Constrained Embedded Systems" /><published>2023-12-22T12:41:00+01:00</published><updated>2023-12-22T12:41:00+01:00</updated><id>http://localhost:4000/posts/Exploring%20Exception%20Handling%20Mechanisms%20in%20Embedded%20Environments</id><content type="html" xml:base="http://localhost:4000/posts/Exploring-Exception-Handling-Mechanisms-in-Embedded-Environments/"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>This article provides a comprehensive analysis of exception handling mechanisms specifically designed for embedded systems, where resource constraints and performance optimization are paramount. In such environments, traditional C++ exception handling is often deemed impractical due to the substantial overhead it incurs. Consequently, developers frequently resort to disabling exceptions using compiler flags such as <code class="language-plaintext highlighter-rouge">-fno-exceptions</code>. Despite this, the necessity for robust error management remains critical, especially in scenarios where system stability must be preserved in the face of unexpected errors.</p>

<p>To address these challenges, this article explores a range of alternative error-handling strategies that are more suitable for embedded systems. The discussion begins with low-level constructs such as <code class="language-plaintext highlighter-rouge">goto</code> statements and function pointers, which provide direct and efficient methods for error management. It then advances to more sophisticated techniques involving <code class="language-plaintext highlighter-rouge">setjmp</code> and <code class="language-plaintext highlighter-rouge">longjmp</code>, which enable the simulation of exception handling with minimal resource consumption. Through detailed and practical examples, we illustrate how these methods can be effectively implemented in resource-constrained environments, ensuring that errors are managed gracefully without compromising system performance.</p>

<p>In addition to these low-level approaches, the article also examines modern C++ techniques that offer lightweight alternatives to traditional exceptions. Constructs like <code class="language-plaintext highlighter-rouge">std::optional</code> and <code class="language-plaintext highlighter-rouge">std::variant</code> provide structured and efficient methods for error handling, allowing for more granular and type-safe error management with minimal overhead. These modern techniques are particularly advantageous in embedded systems where performance and memory efficiency are critical.</p>

<p>Furthermore, the article addresses the complexities introduced by these alternative methods, particularly concerning resource management and cleanup. Practical solutions are presented to prevent issues such as memory leaks, which are essential for ensuring the long-term reliability of embedded systems. By the conclusion of this article, readers will have gained a thorough understanding of how to implement robust and efficient error-handling mechanisms, leveraging both traditional and modern C++ approaches. This knowledge is vital for enhancing the reliability and sustainability of mission-critical applications in embedded environments.</p>

<h2 id="understanding-setjmp-and-longjmp">Understanding setjmp and longjmp</h2>

<h3 id="low-level-error-handling-a-pragmatic-approach">Low-Level Error Handling: A Pragmatic Approach</h3>

<p>Before exploring advanced error-handling constructs like <code class="language-plaintext highlighter-rouge">setjmp</code> and <code class="language-plaintext highlighter-rouge">longjmp</code>, it is instructive to examine a fundamental, low-level approach to error management using function pointers and the <code class="language-plaintext highlighter-rouge">goto</code> statement. This method operates closer to the hardware, offering a highly efficient solution in embedded contexts where minimizing computational overhead is essential.</p>

<p>Consider the following code snippet, which demonstrates this approach:</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;

// environment
void* try_block = nullptr;
volatile int errorCode = 0;

void riskyFunction() {

    // Simulate the effect of longjmp
    std::cout &lt;&lt; "Starting a risky function.\n";
    
    // Mimic throwing an exception (error code: 1)
    if (try_block) {
        errorCode = 1;        // Simulate setting an error code
        goto *try_block;      // Jump back to the try block
    }

    std::cout &lt;&lt; "No errors detected.\n";
}

int main() {

    // Save the address of the try block
    try_block = &amp;&amp;try_block_label;

try_block_label:
    if (errorCode == 0) {
        riskyFunction();
    } else {
        std::cout &lt;&lt; "An error occurred!\n";
    }

    return 0;
}
</code></pre>

<p>The output:</p>

<pre><code class="language-txt">&gt;&gt;&gt;
Starting a risky function.
An error occurred!
</code></pre>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">void* try_block</code>:</p>

    <p>This pointer stores the address of a specific code location, effectively serving as a jump target.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">volatile int errorCode</code>:</p>

    <p>This global variable indicates whether an error has occurred. The <code class="language-plaintext highlighter-rouge">volatile</code> qualifier ensures that the variable’s value is always read directly from memory, which is crucial in environments where memory consistency is a concern.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">riskyFunction</code>:</p>

    <p>This function simulates a risky operation. If an error is detected, the function jumps back to the location pointed to by <code class="language-plaintext highlighter-rouge">try_block</code>, updating the <code class="language-plaintext highlighter-rouge">errorCode</code> to signal the error.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">goto</code>:</p>

    <p>The <code class="language-plaintext highlighter-rouge">goto</code> statement allows the program to jump back to the <code class="language-plaintext highlighter-rouge">try_block_label</code> if an error is detected, thereby simulating a rudimentary exception handling mechanism.</p>
  </li>
</ul>

<p>While this approach is relatively straightforward, it can be effective in highly constrained environments where even the overhead of <code class="language-plaintext highlighter-rouge">setjmp</code> and <code class="language-plaintext highlighter-rouge">longjmp</code> might be undesirable. However, it is less flexible and more prone to errors compared to higher-level constructs.</p>

<h3 id="advanced-error-handling-leveraging-setjmp-and-longjmp">Advanced Error Handling: Leveraging <code class="language-plaintext highlighter-rouge">setjmp</code> and <code class="language-plaintext highlighter-rouge">longjmp</code></h3>

<p>For scenarios that demand a higher level of abstraction and control, <code class="language-plaintext highlighter-rouge">setjmp</code> and <code class="language-plaintext highlighter-rouge">longjmp</code> offer a powerful mechanism to save and restore the program’s execution context. The <code class="language-plaintext highlighter-rouge">setjmp</code> function captures the current environment—including the stack context and registers—into a buffer (typically of type <code class="language-plaintext highlighter-rouge">jmp_buf</code>), while <code class="language-plaintext highlighter-rouge">longjmp</code> restores this environment, effectively reverting the program’s state to the point where <code class="language-plaintext highlighter-rouge">setjmp</code> was initially invoked.</p>

<p>Consider the following implementation:</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;csetjmp&gt;

jmp_buf environment;

void riskyFunction() {
    if (/* some error condition */) {
        // Simulates throw Error(code=1)
        longjmp(environment, 1);
    }
    std::cout &lt;&lt; "No errors detected.\n";
}

int main() {
    int errorCode = setjmp(environment);
    if (errorCode == 0) {
        // Simulates Try block
        riskyFunction();
    } else {
        // Simulates Catch block
        std::cout &lt;&lt; "An error occurred!\n";
    }
    return 0;
}
</code></pre>

<p>This example illustrates the practical utility of <code class="language-plaintext highlighter-rouge">setjmp</code> and <code class="language-plaintext highlighter-rouge">longjmp</code> in managing control flow amidst errors—a particularly valuable capability in embedded systems where traditional exception handling is not feasible.</p>

<h3 id="handling-typed-exceptions-with-setjmp-and-longjmp">Handling Typed Exceptions with <code class="language-plaintext highlighter-rouge">setjmp</code> and <code class="language-plaintext highlighter-rouge">longjmp</code></h3>

<p>The conceptual framework provided by <code class="language-plaintext highlighter-rouge">setjmp</code> and <code class="language-plaintext highlighter-rouge">longjmp</code> can be extended to handle multiple error types, each requiring a distinct response. This approach allows developers to implement typed exceptions, even in environments where conventional C++ exceptions are unavailable.</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;csetjmp&gt;

jmp_buf environment;

int constexpr ValueException  = 1;
int constexpr SyntaxException = 2;

void riskyFunction() {

    if (/* some error condition for value correctness*/) {
        // Simulates throw ValueException;
        longjmp(environment, ValueException);
    }
    
    if (/* some error condition for syntax correctness*/) {
        // Simulates throw SyntaxException;
        longjmp(environment, SyntaxException);
    }

    std::cout &lt;&lt; "No errors detected.\n";
}

int main() {
    int errorCode = setjmp(environment);
    if (errorCode == 0) {
    
        // Simulates Try block
        riskyFunction();
        
    } else if (errorCode == ValueException) {
    
        // Handle Value Error
        std::cout &lt;&lt; "ValueException ocurred\n";
        
    } else if (errorCode == SyntaxException) {
    
        // Handle Syntax Error
        std::cout &lt;&lt; "SyntaxException ocurred\n";
        
    }
    return 0;
}

</code></pre>

<p>This code demonstrates how <code class="language-plaintext highlighter-rouge">longjmp</code> can be employed to simulate typed exception handling, a practice commonly seen in state-based error handling within C. This approach not only enhances the robustness of error management but also introduces a level of granularity that aligns with the nuanced requirements of embedded systems.</p>

<h3 id="exception-propagation-implementing-exception-cascades">Exception Propagation: Implementing Exception Cascades</h3>

<p>In more complex embedded applications, it is often necessary to propagate exceptions through multiple layers of function calls. The following example illustrates how <code class="language-plaintext highlighter-rouge">longjmp</code> can be utilized to create exception cascades, allowing errors to be propagated and handled at different levels of the program.</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;csetjmp&gt;

jmp_buf environment;

void riskyFunction() {
    longjmp(environment, 1);
}

void secondFunction() {
    longjmp(environment, 2);
}

int main() {
    int errorCode = setjmp(environment);
    if (errorCode == 0) {
    
        // Calling a risky function
        riskyFunction();
        
    } else if (errorCode == 1) {
    
        // Handling an error (which can also be handling)
        std::cout &lt;&lt; "riskyFunction called longjmp\n";
        secondFunction();
        
    } else if (errorCode == 2) {
    
        // Exception was thrown while handling another exception
        std::cout &lt;&lt; "secondFunction called longjmp\n";
        
    }
    return 0;
}
</code></pre>

<p>This implementation showcases the flexibility of <code class="language-plaintext highlighter-rouge">longjmp</code> in orchestrating complex control flows within an embedded system. By allowing control to be transferred between disparate parts of the program, <code class="language-plaintext highlighter-rouge">longjmp</code> enables a more nuanced and responsive error-handling strategy, essential in high-stakes embedded applications.</p>

<h2 id="simulating-exception-handling-in-embedded-systems-using-setjmp-and-longjmp">Simulating Exception Handling in Embedded Systems Using <code class="language-plaintext highlighter-rouge">setjmp</code> and <code class="language-plaintext highlighter-rouge">longjmp</code></h2>

<h3 id="designing-a-basic-exception-handling-framework">Designing a Basic Exception Handling Framework</h3>

<p>The utility of <code class="language-plaintext highlighter-rouge">setjmp</code> and <code class="language-plaintext highlighter-rouge">longjmp</code> extends beyond simple error signaling; these functions can be taken advantage of to construct a rudimentary exception-handling framework that mimics the <code class="language-plaintext highlighter-rouge">try</code>-<code class="language-plaintext highlighter-rouge">catch</code> paradigm of higher-level programming languages. Such a framework is particularly advantageous in embedded systems where traditional C++ exceptions are either impractical or outright disabled.</p>

<h3 id="practical-example-integrating-resource-management-with-exception-handling">Practical Example: Integrating Resource Management with Exception Handling</h3>

<p>In embedded systems, resource management is a critical concern, especially given the limited availability of memory and processing power. The following example demonstrates how to implement a simple yet effective exception-handling mechanism that integrates resource management, ensuring that resources are properly released even in the presence of errors.</p>

<p>Let’s define an <code class="language-plaintext highlighter-rouge">ExceptionHandler</code> class that replicates the behavior of <code class="language-plaintext highlighter-rouge">try</code>-<code class="language-plaintext highlighter-rouge">catch</code> blocks in a controlled embedded environment:</p>

<pre><code class="language-cpp">class ExceptionHandler {
public:

    // Register Try block
    ExceptionHandler&amp; Try(std::function&lt;void()&gt; func);

    // Register Catch block
    ExceptionHandler&amp; Catch(std::function&lt;void(int)&gt; func);

    // Execute try/catch
    void Execute();

    // Reset the handler
    void reset();

    // throw an exception
    void throwException(int error = 1);

private:
    bool                     isConfigured_ = false;
    jmp_buf                  environment_;
    std::function&lt;void()&gt;    tryBlock_;
    std::function&lt;void(int)&gt; catchBlock_;
};
</code></pre>

<p>In this implementation, the <code class="language-plaintext highlighter-rouge">Try</code> and <code class="language-plaintext highlighter-rouge">Catch</code> methods serve as configuration functions that register their respective blocks of code:</p>

<pre><code class="language-cpp">ExceptionHandler&amp; ExceptionHandler::Try(std::function&lt;void()&gt; func) {
    tryBlock_     = func;
    isConfigured_ = true;
    return *this;
}

ExceptionHandler&amp; ExceptionHandler::Catch(std::function&lt;void(int)&gt; func) {
    catchBlock_ = func;
    return *this;
}
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">throwException</code> method triggers the exception handling by calling <code class="language-plaintext highlighter-rouge">longjmp</code> with the appropriate error code:</p>

<pre><code class="language-cpp">void ExceptionHandler::throwException(int error) {
    longjmp(env_, error);
}
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">Execute</code> method coordinates the execution of the <code class="language-plaintext highlighter-rouge">Try</code> and <code class="language-plaintext highlighter-rouge">Catch</code> blocks, managing control flow based on whether an exception has been thrown:</p>

<ul>
  <li>Setting up the jump environment.</li>
  <li>Executing the <code class="language-plaintext highlighter-rouge">Try</code> block.</li>
  <li>If an error occurs, executing the <code class="language-plaintext highlighter-rouge">Catch</code> block and passing the error code.</li>
  <li>Resetting the handler for the next pair of try-catch blocks.</li>
</ul>

<pre><code class="language-cpp">void ExceptionHandler::Execute() {

    // Ensure the Try and Catch blocks are properly configured
    if (!isConfigured_)  return;
    
    // Set up the environment for potential exceptions
    int result = setjmp(env_);
    if (result == 0) {
        tryBlock_();
    } else {
        catchBlock_(result);
    }

    // Reset the handler state for future use
    reset();
}


void ExceptionHandler::reset() {
    tryBlock_     = nullptr;
    catchBlock_   = nullptr;
    isConfigured_ = false;
}
</code></pre>

<p>Here is an example of how this class might be used:</p>

<pre><code class="language-cpp">int main() {
    ExceptionHandler handler;

    handler.Try([&amp;] {
        // Try block

        std::cout &lt;&lt; "Try block: an error is about to occur.\n";

        // Trigger an exception
        handler.throwException(2);

        std::cout &lt;&lt; "This will not be printed.\n";

    }).Catch([](int error) {
    
        // Handle the exception in the Catch block
        std::cout &lt;&lt; "Catch block: caught error code " &lt;&lt; error &lt;&lt; "!\n";

    }).Execute();

    std::cout &lt;&lt; "Program continues after try/catch.\n";

    return 0;
}
</code></pre>

<p>The output of this program would be:</p>

<pre><code class="language-txt">&gt;&gt;&gt;
Try block: an error is about to occur.
Catch block: An exception was caught with error code (2)!
Program continues after try/catch.
</code></pre>

<h2 id="c-resources">C++ Resources</h2>

<p>One of the strengths of C++ is its ability to automatically invoke the destructor of a class when it goes out of scope, whether the scope ends normally (by <code class="language-plaintext highlighter-rouge">}</code>) or through an exception. This ensures that resources are freed properly, even when they are allocated within nested functions. This feature, known as <em>stack unwinding</em>, is absent when using the <code class="language-plaintext highlighter-rouge">goto</code> keyword. A critical question arises: do we retain this feature when using <code class="language-plaintext highlighter-rouge">longjmp</code>?</p>

<h3 id="cleaning-up-with-longjmp">Cleaning Up with Longjmp</h3>

<p>The answer is compiler-dependent. For instance, with the <strong>MSVC</strong> compiler, stack unwinding is supported with <code class="language-plaintext highlighter-rouge">longjmp</code>, as evidenced by the following statement: (see <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/longjmp">here</a>)</p>

<blockquote>
  <p>In Microsoft C++ code on Windows, <strong><code class="language-plaintext highlighter-rouge">longjmp</code></strong> uses the same stack-unwinding semantics as exception-handling code. It’s safe to use in the same places that C++ exceptions can be raised.</p>
</blockquote>

<p>However, this would be assuming exception semantics are allowed, which is not the case in embedded environments.</p>

<p>In GCC and ARM compilers, exception semantics are excluded from <code class="language-plaintext highlighter-rouge">longjmp</code>. To demonstrate this, consider a <code class="language-plaintext highlighter-rouge">Resource</code> class that tracks resource allocation and deallocation:</p>

<pre><code class="language-cpp">class Resource {
public:
    Resource(const std::string&amp; name) : name_(name) {
        std::cout &lt;&lt; name_ &lt;&lt; " constructed!\n";
    }

    ~Resource() {
        std::cout &lt;&lt; name_ &lt;&lt; " destructed!\n";
    }

private:
    std::string name_;
};
</code></pre>

<p>Now, let’s use this class as follows:</p>

<pre><code class="language-cpp">// Global Exception Handler
ExceptionHandler handler;

int main() {

    handler.Try([&amp;] {
        // Try block

        // This will not be destructed with throwException/longjmp
        Resource res("MyResource"); 

        std::cout &lt;&lt; "Try block: an error is about to occur.\n";

        // Throw Exception
        handler.throwException(2);

        std::cout &lt;&lt; "This will not be printed.\n";

    }).Catch([](int error) {

        // Catch an error
        std::cout &lt;&lt; "Catch block: caught error code (" &lt;&lt; error &lt;&lt; ")!\n";

    }).Execute();

    std::cout &lt;&lt; "Program continues after try/catch.\n";

    return 0;
}
</code></pre>

<p>The output would be:</p>

<pre><code class="language-txt">&gt;&gt;&gt;
MyResource constructed!
Try block: an error is about to occur.
Catch block: An exception was caught with error code (2)!
Program continues after try/catch.
</code></pre>

<p>As observed, the destructor for <code class="language-plaintext highlighter-rouge">MyResource</code> is not invoked, potentially leading to memory leaks—a serious concern in embedded systems.</p>

<h3 id="manual-stack-unwinding">Manual Stack Unwinding</h3>

<p>To address the previous issue, we can manually manage resource cleanup by extending the <code class="language-plaintext highlighter-rouge">ExceptionHandler</code> class:</p>

<pre><code class="language-cpp">template &lt;typename T&gt;
void registerCleanup(T&amp; resource)
{
    cleanupStack_.emplace_back([&amp;resource](){
      resource.~T();
    });
}
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">cleanupStack_</code> is a vector of destructor functions that are invoked when an exception is thrown:</p>

<pre><code class="language-cpp">std::vector&lt;std::function&lt;void()&gt;&gt; cleanupStack_;
</code></pre>

<p>When an exception is thrown, all registered variables are destructed:</p>

<pre><code class="language-cpp">void ExceptionHandler::throwException(int error)
{
    // Execute destructors first
    for (auto it = cleanupStack_.rbegin(); it != cleanupStack_.rend(); ++it) (*it)();
    cleanupStack_.clear();

    // Then perform long jump
    longjmp(env_, error);
}
</code></pre>

<p>This solution requires developers to manually register each local resource, as demonstrated below:</p>

<pre><code class="language-cpp">// Global Exception Handler
ExceptionHandler handler;

void riskyFunction()
{
    // Resource
    Resource localRes("ResourceInFunction");

    // Register the source before any exception might be thrown
    handler.registerCleanup(localRes);

    // Throw an exception
    handler.throwException(4);

    std::cout &lt;&lt; "functionWithLocalResource: This line won't be executed if an exception is thrown.\n";
}

int main() {

    handler.Try([&amp;] {
        // Try block

        // This will not be destructed with throwException/longjmp
        Resource res("MyResource"); 

        // Register the source before any exception might be thrown
        handler.registerCleanup(res);

        std::cout &lt;&lt; "Try block: an error is about to occur.\n";

        // Call a risky function
        riskyFunction(handler);

        std::cout &lt;&lt; "This will not be printed.\n";

    }).Catch([](int error) {

        // Catch an error
        std::cout &lt;&lt; "Catch block: caught error code (" &lt;&lt; error &lt;&lt; ")!\n";

    }).Execute();

    std::cout &lt;&lt; "Program continues after try/catch.\n";

    return 0;
}
</code></pre>

<p>The output now reflects proper resource cleanup:</p>

<pre><code class="language-txt">&gt;&gt;&gt;
MyResource constructed!
ResourceInFunction constructed!
ResourceInFunction destructed!
MyResource destructed!
Catch block: An exception was caught with error code (2)!
Program continues after try/catch.
</code></pre>

<p>Now, the destructors are invoked as expected. However, it is easy to overlook registering a local variable, which could lead to subtle bugs.</p>

<h3 id="considerations-for-embedded-systems-balancing-complexity-and-efficiency">Considerations for Embedded Systems: Balancing Complexity and Efficiency</h3>

<p>While <code class="language-plaintext highlighter-rouge">setjmp</code> and <code class="language-plaintext highlighter-rouge">longjmp</code> offer a powerful means of simulating exception handling in embedded systems, they also introduce significant complexity, particularly in terms of managing the cleanup stack. This complexity is exacerbated in resource-constrained environments, where developers must meticulously balance performance, memory usage, and error handling. The manual cleanup required by GCC and ARM compilers adds another layer of difficulty, emphasizing the importance of thorough testing and validation to ensure system reliability.</p>

<h2 id="alternative-approaches-simplifying-with-goto">Alternative Approaches: Simplifying with <code class="language-plaintext highlighter-rouge">goto</code></h2>

<p>In some embedded systems, simplicity and efficiency may outweigh the benefits of structured exception handling. In such cases, using the <code class="language-plaintext highlighter-rouge">goto</code> statement can provide a straightforward and pragmatic error-handling mechanism, albeit at the cost of abstraction and safety.</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;


int riskyFunction() {
    Resource localRes("ResourceInFunction");

    // Assume an error happened
    int errorCode = doSomething(); // returns errorCode 4

    // Check for an error
    if (errorCode != 0) {
        goto cleanup;
    }

    std::cout &lt;&lt; "riskyFunction: This line won't be executed if an error occurs.\n";

cleanup:
    // Clean up resources if necessary
    localRes.release();

    // Return the error code
    return errorCode;
}


int main() {
    int errorCode = 0;
    Resource res("MyResource");

    std::cout &lt;&lt; "Try block: an error is about to occur.\n";

    // Call the risky function and handle errors
    errorCode = riskyFunction();
    if (errorCode != 0) {
        goto cleanup;
    }

    std::cout &lt;&lt; "This will not be printed if an error occurs.\n";

cleanup:
    // Clean up resources
    res.release();

    if (errorCode != 0) {
        std::cout &lt;&lt; "Catch block: caught error code (" &lt;&lt; errorCode &lt;&lt; ")!\n";
    }

    std::cout &lt;&lt; "Program continues after try/catch.\n";

    return errorCode;
}
</code></pre>

<h2 id="alternative-approaches-modern-c">Alternative Approaches: Modern C++</h2>

<p>Beyond the low-level techniques previously discussed, modern C++ introduces several lightweight alternatives to traditional exceptions that are particularly advantageous in resource-constrained embedded systems. These alternatives, including <code class="language-plaintext highlighter-rouge">std::optional</code>, <code class="language-plaintext highlighter-rouge">std::variant</code>, and error codes encapsulated within classes, offer a structured and efficient approach to error handling. Their minimal overhead makes them well-suited for environments where performance and memory efficiency are paramount.</p>

<h3 id="utilizing-stdoptional-for-error-handling">Utilizing <code class="language-plaintext highlighter-rouge">std::optional</code> for Error Handling</h3>

<p>The <code class="language-plaintext highlighter-rouge">std::optional</code> type, introduced in C++17, encapsulates an object that may or may not hold a value. This type is especially beneficial for functions that might fail to produce a meaningful result, allowing the function to return an “empty” state rather than throwing an exception or returning an error code.</p>

<h4 id="example">Example</h4>

<pre><code class="language-cpp">#include &lt;iostream&gt;  
#include &lt;optional&gt;  
  
std::optional&lt;int&gt; riskyFunction(int value) { 
  
    // Return an empty optional to indicate an error  
    if (value &lt; 0) return std::nullopt;  
  
    // Return the result as an optional  
    return value * 2;  
}  
  
int main() {  
    auto result = riskyFunction(-5);  
    
    // Handle the error
    if (!result) {  
       std::cout &lt;&lt; "An error occurred: invalid input.\n";  
       exit(0);  // Early termination
    }  
  
    // Valid input, retrieve and display the value
    std::cout &lt;&lt; "Result: " &lt;&lt; result.value() &lt;&lt; "\n";  
    
    return 0;  
}
</code></pre>

<p>In this example, the function <code class="language-plaintext highlighter-rouge">riskyFunction</code> returns an <code class="language-plaintext highlighter-rouge">std::optional&lt;int&gt;</code>, which either contains a valid result or <code class="language-plaintext highlighter-rouge">std::nullopt</code> if an error occurs. This approach avoids the overhead of exceptions while providing a clear mechanism for error checking.</p>

<h3 id="leveraging-stdvariant-for-typed-errors">Leveraging <code class="language-plaintext highlighter-rouge">std::variant</code> for Typed Errors</h3>

<p><code class="language-plaintext highlighter-rouge">std::variant</code>, also introduced in C++17, is a type-safe union that can store one of several types, making it a versatile tool for returning either a result or an error type from a function. This is analogous to using tagged unions in C but with the added safety and flexibility offered by modern C++.</p>

<h4 id="example-for-variant">Example for variant</h4>

<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;variant&gt;
#include &lt;string&gt;

// Value Error Type
struct ValueError {  
    std::string message;  
};  
  
// Syntax Error Type
struct SyntaxError {  
    std::string message;  
};  

// Result type can be an integer, a value error, or a syntax error
using Result = std::variant&lt;int, ValueError, SyntaxError&gt;;  
  
Result riskyFunction(int value) {  

    // Return a ValueError if the input is negative
    if (value &lt; 0)  return ValueError{"Value cannot be negative"}; 
     
    // Return a SyntaxError if the input is zero
    if (value == 0) return SyntaxError{"Value cannot be zero"};  

    // Return the value
    return value * 2;  
}  
  
int main() {  
    auto result = riskyFunction(0); 
     
    // Check for a ValueError
    if (std::holds_alternative&lt;ValueError&gt;(result)) {
       std::cout &lt;&lt; "Value error: " &lt;&lt; std::get&lt;ValueError&gt;(result).message &lt;&lt; "\n";  
       exit(0);
    }
    
    // Check for a SyntaxError
    if (std::holds_alternative&lt;SyntaxError&gt;(result)) {
       std::cout &lt;&lt; "Syntax error: " &lt;&lt; std::get&lt;SyntaxError&gt;(result).message &lt;&lt; "\n";  
       exit(0);
    }

    // Otherwise, an integer result is assumed
    std::cout &lt;&lt; "Result: " &lt;&lt; std::get&lt;int&gt;(result) &lt;&lt; "\n";  
  
    return 0;  
}
</code></pre>

<p>In this instance, <code class="language-plaintext highlighter-rouge">riskyFunction</code> returns a <code class="language-plaintext highlighter-rouge">std::variant&lt;int, ValueError, SyntaxError&gt;</code>, allowing it to return either a valid result or detailed error information. This approach increases the granularity of error handling while avoiding the performance drawbacks associated with exceptions.</p>

<h3 id="encapsulating-error-codes-within-classes">Encapsulating Error Codes within Classes</h3>

<p>Another modern C++ approach involves encapsulating error codes within a class structure. This method enhances code readability and maintainability by associating specific error codes with meaningful class types, as opposed to relying on plain integers.</p>

<p>We will first define a basic <code class="language-plaintext highlighter-rouge">ErrorCode</code> class to encapsulate error types and messages, then construct a <code class="language-plaintext highlighter-rouge">Result</code> class template that encapsulates either a value or an error. Finally, we will demonstrate how to utilize these classes in a function that performs a potentially risky operation and returns either a result or an error.</p>

<h4 id="defining-the-errorcode-class">Defining the <code class="language-plaintext highlighter-rouge">ErrorCode</code> Class</h4>

<p>The initial step in constructing our error-handling framework involves defining an <code class="language-plaintext highlighter-rouge">ErrorCode</code> class. This class will represent various types of errors that may occur and will provide a mechanism to retrieve an error message associated with each error type.</p>

<p>Here is the basic structure of the <code class="language-plaintext highlighter-rouge">ErrorCode</code> class:</p>

<pre><code class="language-cpp">// ErrorCode class to represent possible errors
class ErrorCode {
 public:
    // Enum to define different types of error codes
    enum Code { None, ValueError, SyntaxError };

    // Constructor takes an optional error code and an error message
    explicit ErrorCode(Code code = None, std::string message = "")
        : code_(code), message_(std::move(message)) {}

    // Getter for the error message
    std::string message() const { return message_; }

    // Getter for the error code
    Code code() const { return code_; }

 private:
    Code code_;                ///&lt; error code / type
    std::string message_;      ///&lt; error message
};
</code></pre>

<p>In this structure:</p>

<ul>
  <li><strong>Enum <code class="language-plaintext highlighter-rouge">Code</code></strong>: Enumerates different error types (<code class="language-plaintext highlighter-rouge">None</code>, <code class="language-plaintext highlighter-rouge">ValueError</code>, <code class="language-plaintext highlighter-rouge">SyntaxError</code>).</li>
  <li><strong>Constructor</strong>: Initializes the error code and its associated message.</li>
  <li><strong>Getters</strong>: Provide access to the error code and message.</li>
</ul>

<p>This class forms the foundation for representing errors within our application.</p>

<h4 id="creating-the-result-class-template">Creating the <code class="language-plaintext highlighter-rouge">Result</code> Class Template</h4>

<p>Next, we need a way to return either a valid result or an error from a function. To achieve this, we create a <code class="language-plaintext highlighter-rouge">Result</code> class template that can hold either a value of any type <code class="language-plaintext highlighter-rouge">T</code> or an <code class="language-plaintext highlighter-rouge">ErrorCode</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">Result</code> class is defined as a template, allowing it to accommodate any data type as the potential result of an operation. This flexibility is crucial for creating a general-purpose error-handling mechanism.</p>

<pre><code class="language-cpp">template &lt;typename T&gt;
class Result {
    // Class members and methods will be defined within this template.
};
</code></pre>

<p>By templating the class, we enable <code class="language-plaintext highlighter-rouge">Result</code> to handle various types of results, making it adaptable to different contexts within an application.</p>

<p>The <code class="language-plaintext highlighter-rouge">Result</code> class is designed to accommodate two primary scenarios:</p>

<ol>
  <li>The operation succeeds and returns a value, or</li>
  <li>The operation fails and returns an error.</li>
</ol>

<p>To facilitate these scenarios, the class provides two constructors.</p>

<pre><code class="language-cpp">public:
    // Constructor for a successful result containing a value
    explicit Result(T value) : result_(std::move(value)) {}

    // Constructor for an error result containing an ErrorCode
    Result(ErrorCode error) : result_(std::move(error)) {}
</code></pre>

<ul>
  <li>
    <p><strong>Success Constructor</strong>: This constructor initializes the <code class="language-plaintext highlighter-rouge">Result</code> object with a value of type <code class="language-plaintext highlighter-rouge">T</code>. The use of <code class="language-plaintext highlighter-rouge">std::move</code> ensures efficient handling of the value, particularly when dealing with large or complex objects.</p>
  </li>
  <li>
    <p><strong>Error Constructor</strong>: This constructor initializes the <code class="language-plaintext highlighter-rouge">Result</code> object with an <code class="language-plaintext highlighter-rouge">ErrorCode</code>, signifying that the operation encountered an issue.</p>
  </li>
</ul>

<p>These constructors are fundamental to ensuring that the <code class="language-plaintext highlighter-rouge">Result</code> object can accurately represent either a successful outcome or an error, providing a clear and structured approach to error handling.</p>

<p>To enable the <code class="language-plaintext highlighter-rouge">Result</code> object to hold either a value or an error, the class employs <code class="language-plaintext highlighter-rouge">std::variant</code>. This C++ standard library feature ensures that the object can store one of these types at a time, but not both simultaneously.</p>

<pre><code class="language-cpp">private:
    std::variant&lt;T, ErrorCode&gt; result_; ///&lt; Holds either a value of type T or an ErrorCode
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">std::variant</code> type is integral to the design of the <code class="language-plaintext highlighter-rouge">Result</code> class. It enforces type safety by ensuring that the object contains only a value or an error at any given moment, thus preventing ambiguous states.</p>

<p>A common requirement when dealing with the outcome of an operation is the ability to easily determine whether it succeeded or failed. The <code class="language-plaintext highlighter-rouge">Result</code> class provides an overloaded <code class="language-plaintext highlighter-rouge">bool</code> operator to facilitate this check.</p>

<pre><code class="language-cpp">public:
    // Overloaded bool operator to check if the result contains a value (indicating success)
    explicit operator bool() const {
        return std::holds_alternative&lt;T&gt;(result_);
    }
</code></pre>

<ul>
  <li><strong>Boolean Operator</strong>: This operator checks whether the <code class="language-plaintext highlighter-rouge">Result</code> contains a value of type <code class="language-plaintext highlighter-rouge">T</code>. If it does, the operator returns <code class="language-plaintext highlighter-rouge">true</code>, indicating success; otherwise, it returns <code class="language-plaintext highlighter-rouge">false</code>.</li>
</ul>

<p>This feature enhances the usability of the <code class="language-plaintext highlighter-rouge">Result</code> class by allowing developers to intuitively and efficiently check the success of an operation.</p>

<p>To access the value or error contained within the <code class="language-plaintext highlighter-rouge">Result</code> object, the class provides two methods: <code class="language-plaintext highlighter-rouge">value()</code> and <code class="language-plaintext highlighter-rouge">error()</code>. These methods return <code class="language-plaintext highlighter-rouge">std::optional</code> types, which offer a safe way to handle cases where the requested data might not be present.</p>

<pre><code class="language-cpp">public:
    // Retrieve the value if no error occurred, returning std::optional to handle the absence of a value
    std::optional&lt;T&gt; value() const {
        if (std::holds_alternative&lt;T&gt;(result_)) {
            return std::get&lt;T&gt;(result_);
        }
        return std::nullopt;
    }

    // Retrieve the error if one occurred, returning std::optional to handle the absence of an error
    std::optional&lt;ErrorCode&gt; error() const {
        if (std::holds_alternative&lt;ErrorCode&gt;(result_)) {
            return std::get&lt;ErrorCode&gt;(result_);
        }
        return std::nullopt;
    }
</code></pre>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">value()</code> Method</strong>: This method attempts to retrieve the stored value. If the <code class="language-plaintext highlighter-rouge">Result</code> contains a value, it is returned; if the <code class="language-plaintext highlighter-rouge">Result</code> contains an error, the method returns <code class="language-plaintext highlighter-rouge">std::nullopt</code>, indicating the absence of a value.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">error()</code> Method</strong>: Similarly, this method retrieves the stored error if one is present. If the <code class="language-plaintext highlighter-rouge">Result</code> contains a value instead, it returns <code class="language-plaintext highlighter-rouge">std::nullopt</code>, signifying the absence of an error.</p>
  </li>
</ul>

<p>These methods provide a clear and safe mechanism for extracting the contents of the <code class="language-plaintext highlighter-rouge">Result</code> object, ensuring that error handling is both explicit and reliable.</p>

<p>The <code class="language-plaintext highlighter-rouge">Result</code> class template offers a comprehensive and type-safe mechanism for managing the outcomes of operations that may either succeed or fail. By encapsulating both the value and the error within a single object, it presents a clean and efficient alternative to traditional error-handling strategies, making it particularly suitable for environments where reliability and performance are critical.</p>

<h4 id="implementing-the-result-class-in-a-function">Implementing the <code class="language-plaintext highlighter-rouge">Result</code> Class in a Function</h4>

<p>With the <code class="language-plaintext highlighter-rouge">ErrorCode</code> and <code class="language-plaintext highlighter-rouge">Result</code> classes defined, we can now use them in a function that performs a potentially risky operation. The function will return a <code class="language-plaintext highlighter-rouge">Result&lt;int&gt;</code> to indicate either a successful operation (yielding a result) or an error.</p>

<p>Here’s an example of such a function:</p>

<pre><code class="language-cpp">Result&lt;int&gt; riskyFunction(int value) {

    // If the input value is negative, return a ValueError
    if (value &lt; 0) {
        return ErrorCode(ErrorCode::ValueError, "Value cannot be negative");
    }

    // If the input value is zero, return a SyntaxError
    if (value == 0) {
        return ErrorCode(ErrorCode::SyntaxError, "Value cannot be zero");
    }

    // Input is correct
    return Result&lt;int&gt;(value * 2); // Return the result on success
}
</code></pre>

<p>where</p>

<ul>
  <li><strong>Negative Value</strong>: Returns an <code class="language-plaintext highlighter-rouge">ErrorCode</code> for a <code class="language-plaintext highlighter-rouge">ValueError</code>.</li>
  <li><strong>Zero Value</strong>: Returns an <code class="language-plaintext highlighter-rouge">ErrorCode</code> for a <code class="language-plaintext highlighter-rouge">SyntaxError</code>.</li>
  <li><strong>Valid Value</strong>: Returns the computed result (<code class="language-plaintext highlighter-rouge">value * 2</code>).</li>
</ul>

<p>This function demonstrates how to use the <code class="language-plaintext highlighter-rouge">Result</code> and <code class="language-plaintext highlighter-rouge">ErrorCode</code> classes to handle errors in a structured manner.</p>

<h4 id="managing-the-result-in-the-main-function">Managing the Result in the Main Function</h4>

<p>Finally, we can handle the result of <code class="language-plaintext highlighter-rouge">riskyFunction</code> in the <code class="language-plaintext highlighter-rouge">main</code> function:</p>

<pre><code class="language-cpp">int main() {
    // Call riskyFunction with an input value of 5
    auto result = riskyFunction(5);

    // Check if the result contains an error
    if (!result) {
        // Retrieve the error from the result
        auto error = result.error();

        // Check if the error is a ValueError and print the error message
        if (error &amp;&amp; error-&gt;code() == ErrorCode::ValueError) {
            std::cout &lt;&lt; "Value Error: " &lt;&lt; error-&gt;message() &lt;&lt; "\n";
            exit(0); // or return
        }

        // Check if the error is a SyntaxError and print the error message
        if (error &amp;&amp; error-&gt;code() == ErrorCode::SyntaxError) {
            std::cout &lt;&lt; "Syntax Error: " &lt;&lt; error-&gt;message() &lt;&lt; "\n";
            exit(0); // or return
        }
    } 

    // print the successful result value
    std::cout &lt;&lt; "Result: " &lt;&lt; *result.value() &lt;&lt; "\n";

    return 0;
}
</code></pre>

<p>where</p>

<ul>
  <li><strong>Check for Error</strong>: The <code class="language-plaintext highlighter-rouge">if (!result)</code> block checks if an error occurred.</li>
  <li><strong>Handle ValueError</strong>: If the error is a <code class="language-plaintext highlighter-rouge">ValueError</code>, print the message and exit.</li>
  <li><strong>Handle SyntaxError</strong>: If the error is a <code class="language-plaintext highlighter-rouge">SyntaxError</code>, print the message and exit.</li>
  <li><strong>Print Result</strong>: If no error occurred, print the result.</li>
</ul>

<p>This approach is particularly advantageous in environments where exceptions are disabled or in performance-critical applications where the overhead of exceptions is undesirable. The combination of <code class="language-plaintext highlighter-rouge">std::variant</code>, <code class="language-plaintext highlighter-rouge">std::optional</code>, and custom error codes provides a robust alternative that enhances both code readability and maintainability.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In the highly specialized field of embedded systems development, where resources are tightly constrained, the use of traditional C++ exceptions is often impractical. By adopting alternative techniques such as low-level <code class="language-plaintext highlighter-rouge">goto</code> and function pointers, or more sophisticated methods like <code class="language-plaintext highlighter-rouge">setjmp</code> and <code class="language-plaintext highlighter-rouge">longjmp</code>, developers can implement effective error-handling mechanisms with minimal overhead. Each approach has its advantages and trade-offs, which must be carefully evaluated based on the specific constraints and requirements of the application at hand.</p>

<p>For a quick recap, here is a comparison between discussed methods:</p>

<table>
  <thead>
    <tr>
      <th><strong>Method</strong></th>
      <th><strong>Advantages</strong></th>
      <th><strong>Disadvantages</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">goto</code> and Function Pointers</strong></td>
      <td>- Extremely low overhead, close to the hardware level  <br />- Simple to implement in small, constrained environments</td>
      <td>- Prone to errors and difficult to maintain  <br />- Lacks flexibility and scalability  <br />- No automatic cleanup</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">setjmp</code> and <code class="language-plaintext highlighter-rouge">longjmp</code></strong></td>
      <td>- Provides a mechanism for non-local jumps and structured error handling without exceptions  <br />- Suitable for more complex control flows</td>
      <td>- Requires manual resource management (no stack unwinding)  <br />- Can be complex to implement correctly</td>
    </tr>
    <tr>
      <td><strong>Typed Exceptions with <code class="language-plaintext highlighter-rouge">longjmp</code></strong></td>
      <td>- Allows handling different types of errors distinctly  <br />- Offers more granularity in error management</td>
      <td>- Complexity in implementation  <br />- Manual resource management required</td>
    </tr>
    <tr>
      <td><strong>Exception Cascades with <code class="language-plaintext highlighter-rouge">longjmp</code></strong></td>
      <td>- Enables complex control flow and exception propagation  <br />- Flexible error-handling strategy</td>
      <td>- Even higher complexity  <br />- Difficult to debug and maintain  <br />- Requires thorough testing and validation</td>
    </tr>
    <tr>
      <td><strong>Custom Exception Handler</strong></td>
      <td>- Mimics higher-level <code class="language-plaintext highlighter-rouge">try/catch</code> behavior in embedded C/C++ without runtime overhead<br />- More structured and organized error handling</td>
      <td>- Increased complexity  <br />- Requires manual resource registration and cleanup  <br />- Potential for missed cleanup</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">goto</code> for Cleanup</strong></td>
      <td>- Simple and straightforward for resource cleanup  <br />- Simplifies resource cleanup operations in basic scenarios</td>
      <td>- Lacks abstraction and safety  <br />- Can lead to spaghetti code and is unsuitable for complex error handling<br /></td>
    </tr>
    <tr>
      <td>Raw <code class="language-plaintext highlighter-rouge">std::optional</code> and <code class="language-plaintext highlighter-rouge">std::variant</code></td>
      <td>- Modern C++ features with low overhead, compatible with resource-constrained environments  <br />- Type-safe and integrates well with existing codebases<br /><br /></td>
      <td>- Limited expressiveness compared to full exception handling  <br />- Still requires manual checks and error handling</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Result</code> Class Template</td>
      <td>- Encapsulates error handling in a type-safe manner  <br />- Provides clear and maintainable code structure  <br />- Avoids the runtime overhead of exceptions</td>
      <td>- Increased code complexity  <br />- May be over-engineered for simple error-handling cases</td>
    </tr>
  </tbody>
</table>

<p>In conclusion, there is no one-size-fits-all solution for error handling in embedded systems. The best approach often involves a careful balance between simplicity, efficiency, and flexibility, tailored to the unique challenges of the target environment. By leveraging the techniques discussed in this article, developers can ensure that their embedded systems remain resilient, even in the face of unexpected errors.</p>]]></content><author><name></name></author><category term="Embedded-Development" /><category term="Software-Designs" /><category term="Error" /><category term="Handling" /><category term="Embedded" /><category term="STM32" /><category term="Error-Handling" /><category term="Exception-Handling" /><category term="Resource Optimization" /><category term="setjmp" /><category term="jump" /><category term="goto" /><category term="longjump" /><category term="Low-Level Programming" /><category term="ARM" /><category term="C++" /><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">CMake - Publish Your Own Library</title><link href="http://localhost:4000/posts/CMake-Production/" rel="alternate" type="text/html" title="CMake - Publish Your Own Library" /><published>2023-11-18T13:00:00+01:00</published><updated>2023-11-18T13:00:00+01:00</updated><id>http://localhost:4000/posts/CMake-Production</id><content type="html" xml:base="http://localhost:4000/posts/CMake-Production/"><![CDATA[<h2 id="introduction-to-publishing-cmake-projects">Introduction to Publishing CMake Projects</h2>

<p>When developing a C++ library, especially one meant to be reused across multiple projects or distributed to others, it’s crucial to structure your project effectively and use a build system that facilitates this process. CMake is a powerful and widely-used build system that helps manage the build process in a platform-independent manner. This tutorial will guide you through the process of structuring and publishing your own CMake project, ensuring that your library is not only well-organized but also easy to build, test, and distribute.</p>

<p>CMake projects are organized to streamline the development process, allowing for easy integration of dependencies, consistent build processes across different platforms, and a clear separation between the public API, private code, and other components like tests. By following a well-defined structure, you make your project more maintainable and accessible to other developers, who can easily understand and contribute to your code.</p>

<h2 id="objectives">Objectives</h2>

<p>The primary objective of this article is to provide a comprehensive guide on setting up a CMake-based C++ project for public release. We will cover essential topics such as project structure, CMake configuration, handling platform-specific dependencies, and defining installation rules. By the end of this guide, you will be equipped to publish a well-organized, portable, and easily integrable library.</p>

<p>However, this guide will focus on the CMake configuration and project structuring aspects, rather than delving deeply into the testing or the internal implementation of the library itself. Testing will be mentioned briefly, but the core emphasis will be on preparing your library for public consumption through CMake.</p>

<h2 id="project-structure-overview">Project Structure Overview</h2>

<p>The structure of a CMake project plays a significant role in how easily it can be built, tested, and integrated into other projects. A well-organized project directory helps in separating different concerns such as public headers, source files, dependencies, and configuration files. Below is a typical structure for a CMake-based C++ project, which we will dissect:</p>

<pre><code class="language-bash">my_library_project/                # Project Folder
│
├── CMakeLists.txt                 # Root CMake configuration file
├── cmake/
│   └── my_libraryConfig.cmake.in  # CMake config template for installation
│
├── dependencies/                  # External dependencies for different platforms
│   ├── win_x86_64/                # Dependencies for Windows x64
│   └── linux_x86_64/              # Dependencies for Linux x64
│
├── include/                       # Public header files exposed to users
│   └── my_library/                # Library-specific headers
│       ├── my_library.h           # Main public API header
│       └── my_project_export.h    # Export macros for DLLs/shared libraries
│
├── my_library/                    # Source code for the library
│   ├── CMakeLists.txt             # Module-specific CMake configuration
│   │
│   ├── internal/                  # Internal headers (not exposed to users)
│   │   └── internal_helpers.h     # Helpers and private interfaces
│   │
│   └── source/                    # Implementation files
│       ├── my_library.cpp         # Implementation of the public API
│       └── internal_helpers.cpp   # Implementation of internal functionality
│    
│
└── tests/                         # Test code for the library
    ├── CMakeLists.txt             # CMake Configuration for tests
    └── test_my_library.cpp        # Unit or integration tests
</code></pre>

<p>Breakdown of the Project Structure</p>

<ul>
  <li>
    <p><strong>CMakeLists.txt (Root Level):</strong></p>

    <p>This file serves as the entry point for CMake, defining the project’s configuration and build settings. It sets the required CMake version, specifies the C++ standard, configures platform-specific dependencies, and adjusts compiler flags based on the build type. The file also defines output directories and includes subdirectories for building the main library and associated tests. Additionally, it manages required packages and ensures compatibility across different platforms. (<a href="#root-cmakeliststxt">jump to this section</a>)</p>
  </li>
  <li>
    <p><strong>cmake/ Directory:</strong></p>

    <p>Contains custom CMake modules and configuration templates, such as <code class="language-plaintext highlighter-rouge">my_libraryConfig.cmake.in</code>, which is used for packaging and installing your library. This template allows users to find and link against your library using <code class="language-plaintext highlighter-rouge">find_package</code>. (<a href="#cmake-template-file">jump to this section</a>)</p>
  </li>
  <li>
    <p><strong>dependencies/ Directory:</strong></p>

    <p>This is where you would store any external dependencies your project relies on, especially if they are platform-specific. Subdirectories can be organized by platform, such as <code class="language-plaintext highlighter-rouge">win_x86_64</code> for Windows and <code class="language-plaintext highlighter-rouge">linux_x86_64</code> for Linux. Including dependencies here makes it easier to manage third-party libraries that are not readily available through package managers. Once your library is exported, you can re-utilize your library in another project, by putting it here.</p>
  </li>
  <li>
    <p><strong>include/ Directory:</strong></p>

    <p>This folder contains the public API headers. These are the files that other projects will include when they use your library. The headers are usually organized in a subdirectory named after your library (e.g., <code class="language-plaintext highlighter-rouge">my_library/</code>).
  The main API header (<code class="language-plaintext highlighter-rouge">my_library.h</code>) should include the core functions and classes, while the <code class="language-plaintext highlighter-rouge">my_project_export.h</code> file handles macro definitions that control symbol visibility, which is crucial when building shared libraries.</p>
  </li>
  <li>
    <p><strong>my_library/ Directory:</strong></p>

    <p>This is the main codebase of your library. It typically contains a <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> file if the module needs its own build rules, an <code class="language-plaintext highlighter-rouge">internal/</code> directory for private headers not exposed to users, and a <code class="language-plaintext highlighter-rouge">source/</code> directory for the implementation files (<code class="language-plaintext highlighter-rouge">.cpp</code>). This separation between internal and public components helps in encapsulating the internal details of your library.</p>
  </li>
  <li>
    <p><strong>tests/ Directory:</strong></p>

    <p>Contains unit or integration tests that validate your library’s functionality. These tests are usually written using a testing framework (like Google Test, Catch2, or Boost.Test) and should cover both the public API and critical internal components. The <code class="language-plaintext highlighter-rouge">test_my_library.cpp</code> file is an example test that might include various test cases to ensure your library works as expected. Here we will, however, focus on the project structure rather than on testing.</p>
  </li>
</ul>

<h3 id="export-overview">Export Overview</h3>

<p>Once you install your library, the <code class="language-plaintext highlighter-rouge">installation/</code> directory will contain everything required for others to use and integrate your library into their own projects. Let’s break down each component within this directory:</p>

<pre><code class="language-txt">installation/                                  # Project installation root directory
│
├── bin/                                       # Contains runtime binaries (e.g., DLLs) if provided
│   └── libmy_library.dll                      # Compiled dynamic library (Windows)
|
├── include/                                   # Public header files that exposed to users
│   └── my_library/                            # Namespace for your library headers
│       ├── my_library.h                       # Primary public API header
│       ├── ...                                # Your public API headers
│       └── my_project_export.h                # Export macros for cross-platform compatibility
│
└── lib/                                       # Library and CMake configuration files
    ├── cmake/                                 # CMake package configuration directory
    |   └── my_library/                        # CMake files for library integration
    |       └── my_libraryConfig.cmake         # Configuration file for `find_package`
    |       └── my_libraryConfigVersion.cmake  # Version-specific config for compatibility checks
    |       └── my_libraryTargets.cmake        # Target definitions for linking the library
    └── libmy_library.dll.a                    # Import library for GCC/MinGW (or .lib for MSVC)
</code></pre>

<p>Breakdown of the Installation Structure</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">bin/</code> Directory:</strong></p>

    <p>The <code class="language-plaintext highlighter-rouge">bin/</code> directory holds the runtime binaries of the library.
  It contains the dynamically linked libraries (DLLs) for Windows, which are necessary at runtime when your library is used by external applications.
  These binaries are dynamically loaded during program execution and contain the compiled functionality of the library.</p>

    <p><strong><code class="language-plaintext highlighter-rouge">libmy_library.dll</code></strong>: This is the main dynamic library file for Windows, containing the compiled code that is loaded at runtime. It provides the core functionality of your library to the consumers.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">include/</code> Directory:</strong></p>

    <p>This directory contains all the public API headers that your users will include in their projects to interface with your library.
  These headers define the classes, functions, and macros that are exposed to external projects.
  Organizing them in a subdirectory named after the library ensures clear separation and namespace management.</p>

    <p><strong><code class="language-plaintext highlighter-rouge">my_library.h</code></strong>: The main public header file, this aggregates all the core functions and classes available in your library. It serves as the primary interface for users to access your library’s functionality.</p>

    <p><strong><code class="language-plaintext highlighter-rouge">my_project_export.h</code></strong>: This header defines export macros used for symbol visibility across platforms.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">lib/</code> Directory:</strong></p>

    <p>The <code class="language-plaintext highlighter-rouge">lib/</code> directory contains the static or import libraries and the CMake configuration files necessary for integrating your library with other projects. This directory allows your library to be discovered and linked using CMake’s <code class="language-plaintext highlighter-rouge">find_package</code> command.</p>

    <ul>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">cmake/</code> Directory</strong>:
    This subdirectory contains the CMake configuration files needed to allow other projects to find and link to your library. The files ensure that CMake knows how to configure, locate, and use your library’s targets.</p>
      </li>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">my_libraryConfig.cmake</code></strong>:
    This is the main CMake configuration file used by <code class="language-plaintext highlighter-rouge">find_package</code>. It provides instructions on how to locate the library, including setting the paths for the library binaries and headers, and ensuring that the library is correctly linked.
        You define this file by using a template in the <code class="language-plaintext highlighter-rouge">cmake</code> folder in your project.  (<a href="#cmake-template-file">jump to this section</a>)</p>
      </li>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">my_libraryConfigVersion.cmake</code></strong>:
    This file ensures version compatibility between the library and the consuming project. It allows CMake to check whether the version of the library being used meets the version constraints specified in the consuming project.</p>
      </li>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">my_libraryTargets.cmake</code></strong>:
    This file defines the targets associated with your library. It provides CMake with the necessary details for linking the library, including any dependencies or settings required by the consumer project.</p>
      </li>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">libmy_library.dll.a</code></strong>:
    This is the import library for GCC/MinGW, which allows projects to link against the <code class="language-plaintext highlighter-rouge">.dll</code> file. For MSVC, this would be a <code class="language-plaintext highlighter-rouge">.lib</code> file. It plays a critical role in the linking phase of the build process, providing the required interface to the shared library.</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="root-cmakeliststxt">Root CMakeLists.txt</h2>

<p>The root <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> file is the cornerstone of your project’s build configuration. It defines the essential settings and directives that guide CMake in compiling, linking, and packaging your project. Writing a well-structured <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> ensures that your project is not only maintainable but also portable across different environments and platforms. Below is a detailed explanation of the key components of this file.</p>

<h3 id="minimum-cmake-version-and-project-definition">Minimum CMake Version and Project Definition</h3>

<p>To start, you must define the minimum version of CMake that is required to build your project, as well as the project name and version. This is not only a formality but also a fundamental part of your project’s identity.</p>

<pre><code class="language-cpp">cmake_minimum_required(VERSION 3.20)
project(my_library_project VERSION 0.1.0)
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">cmake_minimum_required</code> command specifies the minimum version of CMake that is required to build your project. This ensures that all developers and continuous integration systems use a compatible version of CMake, avoiding potential issues caused by deprecated or unavailable features in older versions. Here, version 3.20 is chosen to leverage modern CMake capabilities.</p>

<p>The <code class="language-plaintext highlighter-rouge">project</code> command defines the name of the project and its version. This is critical as it not only names your project but also associates a version number with it, which can be useful for packaging and version control purposes.</p>

<h3 id="c-standard-configuration">C++ Standard Configuration</h3>

<p>In a C++ project, it’s critical to enforce a specific C++ standard across all compiled files to ensure consistency and avoid compatibility issues between different compilers or environments.</p>

<pre><code class="language-py"># This specifies that the C++20 standard should be enforced for all targets.
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)
</code></pre>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">CMAKE_CXX_STANDARD</code> is set to <code class="language-plaintext highlighter-rouge">20</code>, which enforces the C++20 standard.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">CMAKE_CXX_STANDARD_REQUIRED</code> directive ensures that the build process will halt if the compiler does not support C++20, preventing potential issues later.</p>
  </li>
  <li>
    <p>Disabling <code class="language-plaintext highlighter-rouge">CMAKE_CXX_EXTENSIONS</code> avoids using compiler-specific language extensions, which enhances the portability of your code across different compilers.</p>
  </li>
</ul>

<h3 id="compiler-flags-based-on-build-type">Compiler Flags Based on Build Type</h3>

<p>Compiler flags are instrumental in controlling the behavior of the compiler, particularly when distinguishing between Debug and Release builds. This section configures these flags to optimize for either debugging or performance, depending on the build type.</p>

<pre><code class="language-cpp">if(CMAKE_BUILD_TYPE STREQUAL Debug)
    message(STATUS "Configuring for a Debug build")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -g3 -Og")
    add_definitions(-DDEBUG_MODE)
else()
    message(STATUS "Configuring for a Release build")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -g0 -O3")
endif()
</code></pre>

<p>In Debug mode, the flags enable detailed debugging information (<code class="language-plaintext highlighter-rouge">-g3</code>) and turn off aggressive optimizations (<code class="language-plaintext highlighter-rouge">-Og</code>) to make the debugging process more straightforward.
Additionally, a <code class="language-plaintext highlighter-rouge">DEBUG_MODE</code> macro is defined, which can be used within your code to conditionally include debug-specific logic.
In Release mode, the configuration focuses on optimization (<code class="language-plaintext highlighter-rouge">-O3</code>) and minimal debug information (<code class="language-plaintext highlighter-rouge">-g0</code>) to ensure maximum performance.</p>

<h3 id="platform-specific-dependency-configuration">Platform-Specific Dependency Configuration</h3>

<p>Handling dependencies can be complex, especially when targeting multiple platforms. This section of the CMakeLists.txt is designed to manage platform-specific dependencies and packaging configurations.</p>

<pre><code class="language-py"># Define the platform-specific paths and packaging configurations.
# This ensures that the correct dependencies are used depending on the platform.
if(WIN32)

    # Set the dependency folder for Windows x64.
    set(DEPENDENCY_FOLDER "${CMAKE_SOURCE_DIR}/dependencies/win_x86_64/")

    # Use ZIP as the packaging format for Windows.
    set(CPACK_GENERATOR "ZIP")


elseif (UNIX AND NOT APPLE)
    # Set the dependency folder for Linux x64.
    set(DEPENDENCY_FOLDER "${CMAKE_SOURCE_DIR}/dependencies/linux_x86_64/")
    
    # Use TGZ (tarball gzip) as the packaging format for Linux.
    set(CPACK_GENERATOR "TGZ")

else()

    # Fatal error if the platform is unsupported.
    message(FATAL_ERROR "Unsupported Platform: ${CMAKE_SYSTEM_NAME}")

endif()
</code></pre>

<p>This code block first checks the platform being used (<code class="language-plaintext highlighter-rouge">WIN32</code> for Windows or <code class="language-plaintext highlighter-rouge">UNIX</code> for Linux) and then sets the appropriate directory for dependencies and the correct packaging format (<code class="language-plaintext highlighter-rouge">ZIP</code> for Windows and <code class="language-plaintext highlighter-rouge">TGZ</code> for Linux). If the platform is not supported, CMake will throw a fatal error, stopping the build process.</p>

<h3 id="cmake-prefix-path">CMake Prefix Path</h3>

<p>The <code class="language-plaintext highlighter-rouge">CMAKE_PREFIX_PATH</code> variable is used to specify additional directories where CMake should look for packages, particularly when they are not located in standard system paths. This is especially useful when working with third-party libraries that are bundled with your project.</p>

<pre><code class="language-py"># Set the CMake prefix path to include platform-specific dependency directories.
# This helps CMake locate the required libraries and packages.
set(CMAKE_PREFIX_PATH
        "${DEPENDENCY_FOLDER}/pkgconfig/"
        "${DEPENDENCY_FOLDER}/some_library/"
)
</code></pre>

<p>By setting the CMAKE_PREFIX_PATH, you direct CMake to search in the specified directories for the necessary libraries and packages, ensuring that the build process can locate and link all required dependencies.</p>

<p>Of course this assumes the dependencies are set for all platforms.</p>

<pre><code class="language-bash">my_library_project/               
└── dependencies/   
    ├── win_x86_64/     
    |   ├── pkgconfig/           
    |   └── some_library/   
    └── linux_x86_64/  
        ├── pkgconfig/           
        └── some_library/   
</code></pre>

<h3 id="finding-and-configuring-packages">Finding and Configuring Packages</h3>

<p>Finding and linking external libraries is a common requirement in C++ projects. The find_package command helps automate this process by locating the necessary libraries and integrating them into your project.</p>

<pre><code class="language-py">find_package(PkgConfig REQUIRED)
</code></pre>

<p>Here, we use find_package to locate the PkgConfig tool, which is required to manage the inclusion of external libraries. By marking it as REQUIRED, we ensure that the build process will stop with an error if PkgConfig is not found, preventing any further issues.</p>

<h3 id="output-directory-configuration">Output Directory Configuration</h3>

<p>To keep the build process organized, it’s important to specify where the compiled binaries and libraries should be output. This not only makes it easier to locate the build artifacts but also keeps your project directory clean.</p>

<pre><code class="language-bash"># Set the output directories for the project.
# These settings ensure that all binaries, libraries, and archives are organized in one place.
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_SOURCE_DIR}/output")
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_SOURCE_DIR}/output")
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_SOURCE_DIR}/output/lib")
</code></pre>

<p>This configuration sets all the runtime executables, shared libraries, and static libraries to be placed in a central <code class="language-plaintext highlighter-rouge">output</code> directory. The distinction between runtime, library, and archive outputs ensures that the files are well-organized.</p>

<h3 id="adding-subdirectories">Adding Subdirectories</h3>

<p>In complex projects, organizing your code into subdirectories makes it easier to manage and maintain. The <code class="language-plaintext highlighter-rouge">add_subdirectory</code> command allows you to include additional CMake configurations from different parts of your project.</p>

<pre><code class="language-bash"># Add subdirectories for the library and tests. 
# This modular approach keeps the project organized and easy to manage.
add_subdirectory(my_library)
add_subdirectory(tests)
</code></pre>

<p>By adding subdirectories, you modularize your project, allowing each component, such as the core library and its tests, to have its own CMakeLists.txt file. This makes the overall project more maintainable and scalable.</p>

<hr />

<h2 id="library-cmakeliststxt">Library CMakeLists.txt</h2>

<p>Now we will look at each section of the <code class="language-plaintext highlighter-rouge">my_library/CMakeLists.txt</code> file, explaining the purpose and nuances of each part.</p>

<h3 id="defining-the-library-target">Defining the Library Target</h3>

<p>In modern CMake, source files for a library are explicitly listed and associated with the target. This approach makes the build process clear and maintainable.</p>

<pre><code class="language-bash"># Define the my_library library target
add_library(my_library SHARED)

# Add sources to the my_library library target
target_sources(my_library PRIVATE
        source/my_library.cpp
        source/internal_helpers.cpp
        # Add more files as needed
)
</code></pre>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">add_library(my_library SHARED)</code>:</strong> This command defines a new library target named <code class="language-plaintext highlighter-rouge">my_library</code> and specifies that it should be built as a shared library (<code class="language-plaintext highlighter-rouge">SHARED</code>).</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">target_sources(my_library PRIVATE ...)</code>:</strong> This command explicitly adds the specified source file (<code class="language-plaintext highlighter-rouge">my_library.cpp</code>) to the <code class="language-plaintext highlighter-rouge">my_library</code> library target. The <code class="language-plaintext highlighter-rouge">PRIVATE</code> keyword indicates that the source file is only relevant to this specific target and will not be exposed to other targets.</p>
  </li>
</ul>

<h3 id="passing-version-information-to-the-source-code">Passing Version Information to the Source Code</h3>

<p>Passing the version number to the source code can be useful for embedding version information into the compiled library, which can be accessed at runtime.</p>

<pre><code class="language-cpp">target_compile_definitions(my_library PRIVATE MY_LIBRARY_VERSION="${PROJECT_VERSION}")
</code></pre>

<p><strong><code class="language-plaintext highlighter-rouge">target_compile_definitions(my_library PRIVATE MY_LIBRARY_VERSION="${PROJECT_VERSION}")</code>:</strong> This command defines a preprocessor macro (<code class="language-plaintext highlighter-rouge">MY_LIBRARY_VERSION</code>) with the value of the project’s version (<code class="language-plaintext highlighter-rouge">${PROJECT_VERSION}</code>), making this version accessible in the source code. The <code class="language-plaintext highlighter-rouge">PRIVATE</code> keyword indicates that this definition is only available within the <code class="language-plaintext highlighter-rouge">my_library</code> target and not propagated to targets that link against this library.</p>

<h3 id="setting-build-flags-for-the-library">Setting Build Flags for the Library</h3>

<p>Defining specific macros during the build process is essential for controlling how the library is compiled and differentiating between internal and external usage of the library. (see <a href="#combined-platform-independent-definition">the section about declaring visiblity</a>)</p>

<pre><code class="language-cpp">target_compile_definitions(my_library PRIVATE BUILDING_MY_LIBRARY="1")
</code></pre>

<p><strong><code class="language-plaintext highlighter-rouge">target_compile_definitions(my_library PRIVATE BUILDING_MY_LIBRARY="1")</code>:</strong> This command establishes the BUILDING_MY_LIBRARY macro with a value of “1”, signaling that the current build is for the library itself. This distinction is crucial for correctly applying the visibility attributes defined earlier, ensuring that internal components are exported properly while maintaining clean separation from the end-user’s environment.</p>

<h3 id="specifying-include-directories">Specifying Include Directories</h3>

<p>Include directories are necessary for resolving header files during compilation. It’s important to specify both build-time and install-time include directories.</p>

<pre><code class="language-rb"># Specify the include directories for the target
target_include_directories(my_library
    PUBLIC
        # Use absolute path for building
        $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/../include&gt;

        # Use relative path for installation
        $&lt;INSTALL_INTERFACE:include&gt;
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/internal
)
</code></pre>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">target_include_directories(my_library PUBLIC ...)</code>:</strong> This command sets up include directories for the <code class="language-plaintext highlighter-rouge">my_library</code> target. The <code class="language-plaintext highlighter-rouge">PUBLIC</code> keyword indicates that these directories should be used both when building the library and when other targets include this library.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">$&lt;BUILD_INTERFACE:...&gt;</code> and <code class="language-plaintext highlighter-rouge">$&lt;INSTALL_INTERFACE:...&gt;</code></strong>: These generator expressions ensure that different paths are used depending on whether the library is being built (<code class="language-plaintext highlighter-rouge">BUILD_INTERFACE</code>) or installed (<code class="language-plaintext highlighter-rouge">INSTALL_INTERFACE</code>). This separation ensures that the correct paths are used in each context, enhancing portability.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/internal</code></strong>: This directory is used for internal headers that should not be exposed to users of the library. The <code class="language-plaintext highlighter-rouge">PRIVATE</code> keyword indicates that these include directories are only used when compiling this target.</li>
</ul>

<h3 id="linking-external-libraries">Linking External Libraries</h3>

<p>To use external libraries like <code class="language-plaintext highlighter-rouge">libmicrohttpd</code>, you need to find and link them to your project. CMake offers several ways to find libraries, including <code class="language-plaintext highlighter-rouge">find_library</code>.</p>

<pre><code class="language-rb"># Find and link the required libmicrohttpd library using pkg-config
find_library(MICROHTTPD_LIB NAMES microhttpd libmicrohttpd)

# Link the static microhttpd library
target_link_libraries(my_library PRIVATE ${MICROHTTPD_LIB})
</code></pre>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">find_library(MICROHTTPD_LIB NAMES microhttpd libmicrohttpd)</code>:</strong> This command searches for the <code class="language-plaintext highlighter-rouge">libmicrohttpd</code> library, storing the path in the <code class="language-plaintext highlighter-rouge">MICROHTTPD_LIB</code> variable. The <code class="language-plaintext highlighter-rouge">NAMES</code> option specifies possible names for the library, accommodating different naming conventions on various systems.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">target_link_libraries(my_library PRIVATE ${MICROHTTPD_LIB})</code>:</strong> This command links the <code class="language-plaintext highlighter-rouge">libmicrohttpd</code> library to the <code class="language-plaintext highlighter-rouge">my_library</code> target. The <code class="language-plaintext highlighter-rouge">PRIVATE</code> keyword ensures that this linkage is only relevant for the <code class="language-plaintext highlighter-rouge">my_library</code> target and is not inherited by other targets that depend on it.</li>
</ul>

<h3 id="configuring-visibility-for-internal-functions">Configuring Visibility for Internal Functions</h3>

<p>To reduce the binary size and improve load times, it’s important to hide internal symbols that do not need to be exposed outside the library.</p>

<pre><code class="language-cpp">target_compile_options(my_library PRIVATE -fvisibility=hidden)
set_target_properties(my_library PROPERTIES CXX_VISIBILITY_PRESET hidden)
set_target_properties(my_library PROPERTIES VISIBILITY_INLINES_HIDDEN YES)
</code></pre>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">target_compile_options(my_library PRIVATE -fvisibility=hidden)</code>:</strong> This option hides symbols by default, making only explicitly marked symbols (using <code class="language-plaintext highlighter-rouge">__attribute__((visibility("default")))</code>) visible outside the library.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">set_target_properties(... PROPERTIES CXX_VISIBILITY_PRESET hidden)</code></strong>: This sets the default visibility of C++ symbols to hidden.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">set_target_properties(... PROPERTIES VISIBILITY_INLINES_HIDDEN YES)</code></strong>: This command hides inline function symbols, further reducing the number of exported symbols and improving binary efficiency.</li>
</ul>

<h3 id="defining-installation-rules-for-the-library"><strong>Defining Installation Rules for the Library</strong></h3>

<p>Installing your library correctly ensures that it can be easily found and used by other projects. The installation rules specify where the library files will be placed on the target system.</p>

<pre><code class="language-php"># Installation Rules
# Define the installation directories
install(TARGETS my_library
        EXPORT my_libraryTargets
        ARCHIVE DESTINATION lib
        LIBRARY DESTINATION lib
        RUNTIME DESTINATION bin
        INCLUDES DESTINATION include
)
</code></pre>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">install(TARGETS my_library ...)</code></strong>: This command defines how the <code class="language-plaintext highlighter-rouge">my_library</code> library should be installed. The <code class="language-plaintext highlighter-rouge">ARCHIVE</code>, <code class="language-plaintext highlighter-rouge">LIBRARY</code>, and <code class="language-plaintext highlighter-rouge">RUNTIME</code> options specify the directories for different types of build outputs (static libraries, shared libraries, and executables, respectively). The <code class="language-plaintext highlighter-rouge">INCLUDES DESTINATION</code> specifies where the public headers will be installed.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">EXPORT my_libraryTargets</code></strong>: This option exports the target, which allows it to be included in the package configuration files, making the library discoverable by other projects using <code class="language-plaintext highlighter-rouge">find_package</code>.</li>
</ul>

<h3 id="installing-public-headers"><strong>Installing Public Headers</strong></h3>

<pre><code class="language-php">install(DIRECTORY ../include/ DESTINATION include)
</code></pre>

<p>Alongside the compiled library, you must install the public headers so that they can be included by other projects.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">install(DIRECTORY ../include/ DESTINATION include)</code>:</strong> This command installs the contents of the public <code class="language-plaintext highlighter-rouge">include/</code> directory to the <code class="language-plaintext highlighter-rouge">include</code> directory on the target system. This is essential for making the public API available to other projects that depend on your library.</li>
</ul>

<h3 id="installing-package-configuration-files"><strong>Installing Package Configuration Files</strong></h3>

<pre><code class="language-php"># Install the package configuration files
install(EXPORT my_libraryTargets
        FILE my_libraryTargets.cmake
        NAMESPACE my_library::
        DESTINATION lib/cmake/my_library
)

# Create and install the package configuration files
include(CMakePackageConfigHelpers)
write_basic_package_version_file(
        "${CMAKE_CURRENT_BINARY_DIR}/my_libraryConfigVersion.cmake"
        VERSION ${PROJECT_VERSION}
        COMPATIBILITY AnyNewerVersion
)

configure_package_config_file(
        "../cmake/my_libraryConfig.cmake.in"
        "${CMAKE_CURRENT_BINARY_DIR}/my_libraryConfig.cmake"
        INSTALL_DESTINATION lib/cmake/my_library
)

install(FILES
        "${CMAKE_CURRENT_BINARY_DIR}/my_libraryConfig.cmake"
        "${CMAKE_CURRENT_BINARY_DIR}/my_libraryConfigVersion.cmake"
        DESTINATION lib/cmake/my_library
)
</code></pre>

<p>To make your library discoverable by CMake’s <code class="language-plaintext highlighter-rouge">find_package</code>, you need to generate and install package configuration files.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">install(EXPORT my_libraryTargets ...)</code>:</strong> This command exports the target configuration, allowing it to be used by <code class="language-plaintext highlighter-rouge">find_package</code> when other projects search for <code class="language-plaintext highlighter-rouge">my_library</code>.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">include(CMakePackageConfigHelpers)</code>:</strong> This includes helpers for generating package configuration files.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">write_basic_package_version_file(...)</code>:</strong> Generates a version file that defines the compatibility of the library with different versions.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">configure_package_config_file(...)</code>:</strong> Configures the main package configuration file, which helps other projects find and link against your library.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">install(FILES ...)</code>:</strong> Installs the generated configuration files to the appropriate directory.</li>
</ul>

<h3 id="configuring-package-information-for-distribution"><strong>Configuring Package Information for Distribution</strong></h3>

<p>Finally, to make the library distributable, package information such as the package name, version, and contact details is configured using <code class="language-plaintext highlighter-rouge">CPack</code>.</p>

<pre><code class="language-php"># Set the package name and version
set(CPACK_PACKAGE_NAME "my_library")
set(CPACK_PACKAGE_VERSION ${PROJECT_VERSION})
set(CPACK_PACKAGE_CONTACT "Mustafa Alotbah &lt;mustafa.alotbah@gmail.com&gt;")

# CPACK_GENERATOR set by root CMakeLists.txt
include(CPack)
</code></pre>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">set(CPACK_PACKAGE_NAME "my_library")</code>:</strong> Sets the name of the package for distribution.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">set(CPACK_PACKAGE_VERSION ${PROJECT_VERSION})</code>:</strong> Sets the package version, aligning it with the project version.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">set(CPACK_PACKAGE_CONTACT "Mustafa Alotbah &lt;mustafa.alotbah@gmail.com&gt;")</code>:</strong> Provides contact information for the package, useful for users or maintainers.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">include(CPack)</code>:</strong> Includes CPack, which handles the creation of distribution packages based on the specified configuration.</li>
</ul>

<h2 id="cmake-template-file">CMake Template File</h2>

<p>The <code class="language-plaintext highlighter-rouge">my_libraryConfig.cmake.in</code> file is a template used by CMake to generate a <code class="language-plaintext highlighter-rouge">my_libraryConfig.cmake</code> file during the installation process. This configuration file plays a crucial role in making your library discoverable and easily integrable into other projects through CMake’s <code class="language-plaintext highlighter-rouge">find_package</code> command.</p>

<pre><code class="language-cpp">@PACKAGE_INIT@

include("${CMAKE_CURRENT_LIST_DIR}/my_libraryTargets.cmake")
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">my_libraryConfig.cmake.in</code> file typically contains initialization code and references to other generated files, such as the <code class="language-plaintext highlighter-rouge">my_libraryTargets.cmake</code>:</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">@PACKAGE_INIT@</code> Macro</strong> is a placeholder that is replaced by CMake with the necessary initialization code when the file is processed. The <code class="language-plaintext highlighter-rouge">@PACKAGE_INIT@</code> macro is essential as it sets up the environment for the package configuration. It ensures that any necessary CMake variables are initialized and that the package configuration is compatible with the CMake version used by the consuming project.</p>
  </li>
  <li>
    <p><strong>Including the <code class="language-plaintext highlighter-rouge">my_libraryTargets.cmake</code> File:</strong> This line includes the <code class="language-plaintext highlighter-rouge">my_libraryTargets.cmake</code> file, which contains the actual definitions of the targets (such as the <code class="language-plaintext highlighter-rouge">my_library</code> library) that will be exported during the installation process.
This inclusion is critical for making the targets available to projects that use <code class="language-plaintext highlighter-rouge">find_package</code> to locate your library.</p>

    <blockquote>
      <p>Including the <code class="language-plaintext highlighter-rouge">my_libraryTargets.cmake</code> file is what allows other projects to link against your library. It ensures that all necessary targets, build settings, and dependencies are correctly set up in the consuming project. Without this inclusion, the library would not be properly registered with CMake, making it unavailable for use.</p>
    </blockquote>
  </li>
</ul>

<h3 id="defining-imported_implib-for-windows-platforms">Defining <code class="language-plaintext highlighter-rouge">IMPORTED_IMPLIB</code> for Windows Platforms</h3>

<p>When distributing libraries on <strong>Windows</strong>, there are often differences in how dynamic libraries (<code class="language-plaintext highlighter-rouge">.dll</code>) are linked, depending on the compiler. For this, we use the <code class="language-plaintext highlighter-rouge">IMPORTED_IMPLIB</code> property in CMake to define the appropriate import library (<code class="language-plaintext highlighter-rouge">.lib</code> or <code class="language-plaintext highlighter-rouge">.dll.a</code>) for Windows toolchains.</p>

<p>We can check if we are on Windows platform <code class="language-plaintext highlighter-rouge">if (WIN32)</code> and in this case we should distinguish between <em>MinGW/GCC</em> where <code class="language-plaintext highlighter-rouge">.dll.a</code> is used, whereas <code class="language-plaintext highlighter-rouge">.lib</code> is used by <em>MSVC</em> compilers.</p>

<pre><code class="language-cpp">if (WIN32)
    # Check for GNU / Mingw Compilers
    if (CMAKE_CXX_COMPILER_ID MATCHES "GNU|MinGW")
        # Configure `IMPORTED_IMPLIB` to point to the .dll.a library that will be created
        set_target_properties(Logify::Logify PROPERTIES
            IMPORTED_IMPLIB "${CMAKE_CURRENT_LIST_DIR}/../../libmy_library.dll.a")
    # Otherwise assume it is MSVC
    else()
        # Configure `IMPORTED_IMPLIB` to point to the .lib library that will be created
        set_target_properties(Logify::Logify PROPERTIES
            IMPORTED_IMPLIB "${CMAKE_CURRENT_LIST_DIR}/../../libmy_library.lib")
    endif()
endif()
</code></pre>

<h2 id="source-code">Source Code</h2>

<p>When designing a C++ library that will be used by other projects, it is crucial to manage the visibility of functions and symbols properly. This is particularly important when creating shared libraries, where you want to expose only the necessary API functions while keeping internal details hidden.</p>

<h3 id="source-code-structure">Source Code Structure</h3>

<p>For demonstration purposes, we will implement a simple API function, <code class="language-plaintext highlighter-rouge">std::string getVersion()</code>, which returns the version of the library. This API function will internally rely on another function, <code class="language-plaintext highlighter-rouge">std::string internalGetVersion()</code>, which should remain hidden from the library users. The internal function will only be accessible within the library’s codebase.</p>

<p>Given that we have configured the default visibility of all symbols to be hidden (as detailed in the <a href="#configuring-visibility-for-internal-functions">section on configuring visibility for internal functions</a>), we must explicitly declare which symbols should be visible to the outside world. This is achieved using visibility attributes that are platform-specific.</p>

<h3 id="declaring-visibility-in-header-files">Declaring Visibility in Header Files</h3>

<p>To control the visibility of our API and internal functions, we use different attributes depending on the platform.</p>

<h4 id="for-gcc-and-msvc-on-windows">For GCC and MSVC on Windows</h4>

<p>When compiling a shared library on Windows, the <code class="language-plaintext highlighter-rouge">__declspec(dllexport)</code> attribute is used to export functions from a DLL, making them available to other projects that link against the DLL. Conversely, <code class="language-plaintext highlighter-rouge">__declspec(dllimport)</code> is used in the client code to import these functions. We encapsulate this logic in a macro <code class="language-plaintext highlighter-rouge">MY_LIBRARY_API</code>:</p>

<pre><code class="language-cpp">#ifdef BUILDING_MY_LIBRARY
#define MY_LIBRARY_API __declspec(dllexport)
#else
#define MY_LIBRARY_API __declspec(dllimport)
#endif
</code></pre>

<h4 id="for-gcc-on-linux">For GCC on Linux</h4>

<p>On Linux, GCC provides a visibility attribute, <code class="language-plaintext highlighter-rouge">__attribute__((visibility("default")))</code>, which is used to mark symbols that should be visible outside the library. We also define an internal visibility attribute to explicitly hide symbols:</p>

<pre><code class="language-cpp">#if defined(__GNUC__) &amp;&amp; __GNUC__ &gt;= 4
#define MY_LIBRARY_API __attribute__((visibility("default")))
#else
#define MY_LIBRARY_API
#endif
</code></pre>

<h4 id="combined-platform-independent-definition">Combined Platform-Independent Definition</h4>

<p>To maintain cross-platform compatibility, we combine these definitions into a single header file, <code class="language-plaintext highlighter-rouge">my_project_export.h</code>. This header ensures that the correct visibility attributes are applied based on the target platform:</p>

<pre><code class="language-cpp">#pragma once

#ifdef _WIN32
#ifdef BUILDING_MY_LIBRARY
#define MY_LIBRARY_API __declspec(dllexport)
#else
#define MY_LIBRARY_API __declspec(dllimport)
#endif
#else
#if defined(__GNUC__) &amp;&amp; __GNUC__ &gt;= 4
#define MY_LIBRARY_API __attribute__((visibility("default")))
#else
#define MY_LIBRARY_API
#endif
#endif
</code></pre>

<ul>
  <li>The flag <code class="language-plaintext highlighter-rouge">BUILDING_MY_LIBRARY</code> is defined in the building process in the <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> of the library, see <a href="#setting-build-flags-for-the-library">here</a>. It is only defined in the build process of the library but must not be defined in the build process of the user.</li>
</ul>

<h3 id="public-api-declaration">Public API Declaration</h3>

<p>In the public API header, <code class="language-plaintext highlighter-rouge">my_library.h</code>, we use the <code class="language-plaintext highlighter-rouge">MY_LIBRARY_API</code> macro to declare the visibility of the <code class="language-plaintext highlighter-rouge">getVersion()</code> function:</p>

<pre><code class="language-cpp">#pragma once

#include "my_project_export.h"
#include &lt;string&gt;

MY_LIBRARY_API std::string getVersion();
</code></pre>

<p>This ensures that <code class="language-plaintext highlighter-rouge">getVersion()</code> is visible to any project that links against the library, while other internal functions remain hidden.</p>

<h3 id="internal-function-declaration">Internal Function Declaration</h3>

<p>In contrast, the internal function <code class="language-plaintext highlighter-rouge">internalGetVersion()</code> is declared in an internal header, <code class="language-plaintext highlighter-rouge">internal_helpers.h</code>, without any visibility attributes, meaning it will remain hidden:</p>

<pre><code class="language-cpp">#pragma once

#include &lt;string&gt;

std::string internalGetVersion();
</code></pre>

<p>Since this header is marked as <code class="language-plaintext highlighter-rouge">PRIVATE</code> in the CMake configuration (as discussed in the <a href="#specifying-include-directories">section on specifying include directories</a>), it is not exposed to the users of the library when the library is installed.</p>

<h3 id="implementing-the-functions">Implementing the Functions</h3>

<p>The internal function <code class="language-plaintext highlighter-rouge">internalGetVersion()</code> is implemented in the <code class="language-plaintext highlighter-rouge">source/internal_helpers.cpp</code> file. This function retrieves the version information, which we previously passed to the source code using a preprocessor definition in our CMake configuration:</p>

<pre><code class="language-cpp">#include "internal_server.h"


std::string internalGetVersion() {
    return MY_LIBRARY_VERSION;
}
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">MY_LIBRARY_VERSION</code> macro was defined earlier in the CMake configuration (as detailed in the <a href="#passing-version-information-to-the-source-code">section on passing version information to the source code</a>).</p>

<p>The <code class="language-plaintext highlighter-rouge">getVersion()</code> API function, which calls the internal function, is implemented in <code class="language-plaintext highlighter-rouge">source/my_library.cpp</code>:</p>

<pre><code class="language-cpp">#include "my_library/my_library.h"
#include "my_library_internal.h"

std::string getVersion() {
    return internalGetVersion();
}
</code></pre>

<p>This structure ensures that while <code class="language-plaintext highlighter-rouge">getVersion()</code> is accessible to external projects, <code class="language-plaintext highlighter-rouge">internalGetVersion()</code> remains encapsulated within the library, hidden from external access.</p>

<h3 id="verifying-visibility-and-symbol-export">Verifying Visibility and Symbol Export</h3>

<p>To verify that only the intended symbols are exposed, you can inspect the exported symbols of the compiled shared library. On Linux, this can be done using the <code class="language-plaintext highlighter-rouge">nm</code> command:</p>

<pre><code class="language-bash">nm -C -D lib/libmy_library.so | grep " T "
&gt;&gt;&gt; 
0000000000001120 T getVersion[abi:cxx11]()
</code></pre>

<p>This command lists all symbols marked as globally visible (<code class="language-plaintext highlighter-rouge">T</code>). As expected, only <code class="language-plaintext highlighter-rouge">getVersion()</code> is exposed.</p>

<p>On Windows, you can use the <code class="language-plaintext highlighter-rouge">dumpbin</code> tool to inspect the DLL exports:</p>

<pre><code class="language-bash">dumpbin /EXPORTS libmy_library.dll
&gt;&gt;&gt; 
...
    ordinal hint RVA      name

          1    0 00001370 _Z10getVersionB5cxx11v

  Summary
...
</code></pre>

<p>Again, only the <code class="language-plaintext highlighter-rouge">getVersion()</code> function is visible, confirming that the internal details of the library remain hidden as intended.</p>

<h2 id="installing-the-project">Installing the Project</h2>

<p>After configuring and building the library, it is crucial to install it correctly. This ensures that all necessary files—binaries, headers, and configuration files—are placed in the appropriate directories, ready for use by other projects.</p>

<pre><code class="language-sh">mkdir build 
cd build
cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release
cmake --build . --config Release
cmake --install . --prefix .
</code></pre>

<p>These commands create a build directory, configure the project for a release build, and then install the library. The installation process places the compiled binaries, headers, and CMake configuration files in the specified prefix directory.</p>

<p>To package the project for distribution, you can use CPack:</p>

<pre><code class="language-sh">cpack
</code></pre>

<p>CPack generates a package (e.g., a ZIP or TGZ file) containing the installed files, making it easy to distribute the library.</p>]]></content><author><name></name></author><category term="Software-Development" /><category term="Cmake" /><category term="Software" /><category term="Cmake" /><category term="Windows" /><category term="C++" /><category term="Library" /><category term="Cross-Platform" /><category term="Build-Systems" /><category term="Dependency-Management" /><category term="Continuous-Integration" /><category term="CI" /><category term="CD/CI" /><summary type="html"><![CDATA[Introduction to Publishing CMake Projects]]></summary></entry><entry><title type="html">CMake - Integrating C++ Libraries</title><link href="http://localhost:4000/posts/CMake-Integrating-C++-Libraries/" rel="alternate" type="text/html" title="CMake - Integrating C++ Libraries" /><published>2023-11-15T17:08:00+01:00</published><updated>2023-11-15T17:08:00+01:00</updated><id>http://localhost:4000/posts/CMake-Integrating%20C++%20Libraries</id><content type="html" xml:base="http://localhost:4000/posts/CMake-Integrating-C++-Libraries/"><![CDATA[<p>In modern C++ development, CMake is an indispensable tool for managing project dependencies.
This comprehensive guide empowers you to effortlessly integrate widely used C++ libraries into your projects using the versatile CMake build system.</p>

<p>We’ll delve into strategies for incorporating <strong>Google Test</strong>, <strong>Google Benchmark</strong>, <strong>OpenCV</strong>, <strong>PkgFinder</strong>, <strong>GStreamer</strong>, <strong>Catch2</strong>, and <strong>Qt</strong>, providing clear instructions and code examples tailored to both <strong>Windows</strong> and <strong>Ubuntu</strong> environments.</p>

<h2 id="streamlining-library-integration-with-cmake"><strong>Streamlining Library Integration with CMake</strong></h2>

<p>CMake offers a robust mechanism for managing external libraries, simplifying the process of adding them to your C++ projects. Here are the fundamental approaches:</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">FetchContent</code> Module:</strong> This convenient module assists in downloading and integrating libraries directly from source repositories. It’s ideal for libraries under active development or those not readily available through package managers.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">find_package</code> Command:</strong> For libraries distributed with package managers (e.g., PkgConfig, Conan, vcpkg, etc.), CMake’s <code class="language-plaintext highlighter-rouge">find_package</code> command simplifies the discovery and linking process.</p>
  </li>
  <li>
    <p><strong>Manual Configuration:</strong> In some cases, you might need to set environment variables or manually specify library and include directories. This approach is usually employed for libraries not managed by package managers.</p>
  </li>
</ul>

<p><strong>Exploring Popular C++ Libraries:</strong></p>

<p>Now, let’s embark on a journey through integrating some of the most popular C++ libraries.</p>

<h2 id="google-test">Google Test</h2>

<p><strong>Purpose</strong>: Google Test is a robust testing framework designed for writing unit tests in C++.</p>

<h3 id="integration-google-test-using-fetchcontent">Integration Google Test using FetchContent</h3>

<p><strong>Windows and Ubuntu Instructions</strong>: The procedure for both systems is identical using CMake’s <code class="language-plaintext highlighter-rouge">FetchContent</code>.</p>

<pre><code class="language-cpp">include(FetchContent)         # to use FetchContent_Declare

# -- START: GOOGLE_TEST_INCLUDE --
FetchContent_Declare(
    googletest
    GIT_REPOSITORY https://github.com/google/googletest.git
    GIT_TAG main
    OVERRIDE_FIND_PACKAGE
)

FetchContent_MakeAvailable(googletest)
include(GoogleTest)         # to use gtest_discover_tests
target_link_libraries(simple_test GTest::gtest_main)
# -- END: GOOGLE_TEST_INCLUDE --

# test files
add_executable(simple_test "simple_test.cpp")
gtest_discover_tests(simple_test)
</code></pre>

<p><strong>Simple Test Code</strong>: <code class="language-plaintext highlighter-rouge">simple_test.cpp</code></p>

<pre><code class="language-cpp"># include &lt;gtest/gtest.h&gt;
TEST(HelloTest, BasicAssertions) {
    // Expect two strings not to be equal.
    EXPECT_STRNE("hello", "world");
    // Expect equality.
    EXPECT_EQ(7 * 6, 42);
}
</code></pre>

<h3 id="installing-google-test-on-ubuntu">Installing Google Test on Ubuntu</h3>

<p>For Ubuntu, you can alternatively install Google Test using <code class="language-plaintext highlighter-rouge">apt</code>:</p>

<pre><code class="language-sh">sudo apt-get install libgtest-dev
</code></pre>

<p>Then manually compile the library and link it to your project.</p>

<h2 id="google-benchmark">Google Benchmark</h2>

<p><strong>Purpose</strong>: Google Benchmark simplifies the process of benchmarking C++ code for performance testing.</p>

<h3 id="integration-google-benchmark-using-fetchcontent">Integration Google Benchmark using FetchContent</h3>

<pre><code class="language-cpp">include(FetchContent)   # to use FetchContent_Declare

# -- START: GOOGLE_BENCHMARK_INCLUDE --
FetchContent_Declare(
    googlebenchmark
    GIT_REPOSITORY https://github.com/google/benchmark.git
    GIT_TAG main
    OVERRIDE_FIND_PACKAGE
)

FetchContent_MakeAvailable(googlebenchmark)
target_link_libraries(${EXE_NAME} benchmark::benchmark)
# -- END: GOOGLE_BENCHMARK_INCLUDE --

# test files
add_executable(simple_benchmark "simple_benchmark.cpp")
gtest_discover_tests(simple_benchmark)
</code></pre>

<p><strong>Example Benchmark Code</strong>: <code class="language-plaintext highlighter-rouge">simple_benchmark.cpp</code></p>

<pre><code class="language-cpp">#include &lt;benchmark/benchmark.h&gt;

static void BM_StringCreation(benchmark::State&amp; state) {
  for (auto _ : state)
    std::string empty_string;
}
// Register the function as a benchmark
BENCHMARK(BM_StringCreation);

static void BM_StringCopy(benchmark::State&amp; state) {
  std::string x = "hello";
  for (auto _ : state)
    std::string copy(x);
}

BENCHMARK(BM_StringCopy);
</code></pre>

<h3 id="installing-google-benchmark-on-ubuntu">Installing Google Benchmark on Ubuntu</h3>

<pre><code class="language-sh">sudo apt-get install libbenchmark-dev
</code></pre>

<p>Update your CMake file:</p>

<pre><code class="language-cpp">find_package(benchmark REQUIRED)
target_link_libraries(MyBenchmarkTarget benchmark::benchmark)
</code></pre>

<h2 id="opencv">OpenCV</h2>

<p><strong>Purpose</strong>: OpenCV is a powerful library for real-time computer vision and image processing.</p>

<h3 id="integration-of-opencv-on-windows">Integration of OpenCV on Windows</h3>

<ul>
  <li>Download the pre-built OpenCV binaries for MinGW from the <a href="https://github.com/huihut/OpenCV-MinGW-Build">OpenCV-MinGW-Build</a>.</li>
  <li>Ensure you add the OpenCV binaries to your <code class="language-plaintext highlighter-rouge">PATH</code> variable.</li>
</ul>

<p><strong>CMakeLists.txt</strong>:</p>

<pre><code class="language-cpp"># Add this
set(OpenCV_DIR "C:\\OpenCV-MinGW-Build-OpenCV-4.5.5-x64")

# Find and link OpenCV
find_package(OpenCV REQUIRED)
target_include_directories(MyApp PRIVATE ${OpenCV_INCLUDE_DIRS})
target_link_libraries(MyApp PRIVATE ${OpenCV_LIBS} )
</code></pre>

<p>To avoid hard coded paths in CMake, you could consider adding <code class="language-plaintext highlighter-rouge">OpenCV_DIR</code> to your system’s <code class="language-plaintext highlighter-rouge">PATH</code> variable.</p>

<h3 id="integration-of-opencv-on-ubuntu">Integration of OpenCV on Ubuntu</h3>

<p>To install OpenCV on Ubuntu:</p>

<pre><code class="language-sh">sudo apt-get install libopencv-dev
</code></pre>

<p>Then update your <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>:</p>

<pre><code class="language-cpp">find_package(OpenCV REQUIRED)
target_link_libraries(MyApp PRIVATE ${OpenCV_LIBS})
</code></pre>

<p><strong>Sample OpenCV Code</strong>: <code class="language-plaintext highlighter-rouge">main.cpp</code></p>

<pre><code class="language-cpp">#include &lt;opencv2/opencv.hpp&gt;

int main(int argc, char *argv[]) {

     // Create a window using OpenCV
     cv::namedWindow("MyWindow", cv::WINDOW_AUTOSIZE);

     // Wait for a keystroke in the window
     cv::waitKey(0);

    return 0;
}
</code></pre>

<h2 id="pkgfinder-package-manager">PkgFinder Package Manager</h2>

<ul>
  <li><strong>Purpose:</strong> A platform-independent package manager for C libraries.</li>
</ul>

<h3 id="integration-of-pkgfinder-on-windows">Integration of PkgFinder on Windows</h3>

<ul>
  <li>
    <p>Download and install the required binaries from the <a href="https://download.gnome.org/binaries/win32/dependencies/">pkg-config website</a>.
Specifically, you’ll need to install the required binaries. Copy the following files into your MinGW64 bin directory:</p>

    <ul>
      <li>
        <p><strong>bin/pkg-config.exe</strong> from <a href="https://download.gnome.org/binaries/win32/dependencies/pkg-config_0.26-1_win32.zip">pkg-config_0.26-1_win32.zip</a></p>
      </li>
      <li>
        <p><strong>bin/intl.dll</strong> from <a href="https://download.gnome.org/binaries/win32/dependencies/gettext-runtime_0.18.1.1-2_win32.zip">gettext-runtime_0.18.1.1-2_win32.zip</a></p>
      </li>
      <li>
        <p><strong>bin/libglib-2.0-0.dll</strong> from <a href="https://download.gnome.org/binaries/win32/glib/2.28/glib_2.28.8-1_win32.zip">glib_2.28.8-1_win32.zip</a></p>
      </li>
    </ul>
  </li>
  <li>
    <p>Note that this is not necessary for <strong>CLion</strong>’s bundled CMake or for <strong>MSVC</strong>.</p>
  </li>
</ul>

<h3 id="installing-on-ubuntu">Installing on Ubuntu</h3>

<pre><code class="language-sh">sudo apt-get install pkg-config
</code></pre>

<p>Example usage in <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code></p>

<pre><code class="language-cpp">find_package(PkgConfig REQUIRED)
pkg_check_modules(LIBNAME REQUIRED libname)
target_include_directories(MyApp PRIVATE ${LIBNAME_INCLUDE_DIRS})
target_link_libraries(MyApp PRIVATE ${LIBNAME_LIBRARIES})
</code></pre>

<h2 id="gstreamer">GStreamer</h2>

<ul>
  <li><strong>Purpose:</strong> GStreamer is a powerful multimedia framework for streaming and video processing.</li>
</ul>

<h3 id="integration-of-gstreamer-on-windows">Integration of GStreamer on Windows</h3>

<p>Gstream requires PkgFinder packe for CMake</p>

<p>To use GStreamer in your C++ projects, ensure the following:</p>

<ol>
  <li>
    <p>Make sure that Microsoft Visual C++ Redistributable is installed (or install it from the official website <a href="https://aka.ms/vs/17/release/vc_redist.x86.exe">vc_redist.x86.exe</a>)</p>
  </li>
  <li>
    <p>Install the GStreamer runtime and SDK (MSVC-64 version) from <a href="https://gstreamer.freedesktop.org/download/">GStreamer’s website</a>.</p>
  </li>
  <li>
    <p>Add the GStreamer’s binary folder to the system <code class="language-plaintext highlighter-rouge">PATH</code> variable.</p>
  </li>
  <li>
    <p>Set the <code class="language-plaintext highlighter-rouge">PKG_CONFIG_PATH</code> environment variable to the GStreamer package config path:<br />
 <code class="language-plaintext highlighter-rouge">PKG_CONFIG_PATH = path/to/gstreamer/1.0/msvc_x86_64/lib/pkgconfig</code>`</p>
  </li>
</ol>

<p>Update your <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>:</p>

<pre><code class="language-cpp">find_package(PkgConfig REQUIRED)

pkg_check_modules(GST REQUIRED gstreamer-1.0)
pkg_search_module(GSTREAMER REQUIRED IMPORTED_TARGET gstreamer-1.0&gt;=1.4)

target_include_directories(MyApp PRIVATE  ${GST_INCLUDE_DIRS})
target_link_libraries(MyApp PRIVATE PkgConfig::GSTREAMER)
</code></pre>

<h3 id="integration-of-gstreamer-on-ubuntu">Integration of GStreamer on Ubuntu</h3>

<p>To install GStreamer:</p>

<pre><code class="language-sh">sudo apt-get install gstreamer1.0-dev
</code></pre>

<h2 id="catch2">Catch2</h2>

<h3 id="downloading-and-installing-catch2">Downloading and Installing Catch2</h3>

<p>Catch2 is another popular testing framework. To add Catch2 to your project, clone the repository and build it:</p>

<pre><code class="language-bash">git clone https://github.com/catchorg/Catch2.git
cd Catch2
# if you want a specific version
git checkout v2.13.9
</code></pre>

<p>Build and install the library:</p>

<pre><code class="language-bash">mkdir build &amp;&amp; cd build
cmake .. -G "MinGW Makefiles"     # or "Visual Studio 17 2022" 
cmake --build . --config Release  # or Debug
cmake --install . --prefix /path  # Path to installation
</code></pre>

<p>By following these instructions, you should be able to seamlessly integrate these libraries into your C++ projects using CMake.</p>

<h2 id="qt6">Qt6</h2>

<p><strong>Purpose</strong>: Qt6 is a modern, cross-platform GUI framework for building high-performance, visually rich applications. Qt6 also includes non-GUI components, making it a comprehensive tool for application development.</p>

<h3 id="integration-of-qt6-on-windows">Integration of Qt6 on Windows</h3>

<ul>
  <li>Firstly, install Qt from <a href="https://www.qt.io/offline-installers">Qt’s official website</a></li>
  <li>Integrating <strong>Qt6</strong> in a self-sufficient manner with CMake involves properly setting up the environment and linking the necessary components.</li>
</ul>

<h3 id="setting-up-cmake">Setting Up CMake</h3>

<ol>
  <li>
    <p>At the <strong>project level</strong>, define the <code class="language-plaintext highlighter-rouge">CMAKE_PREFIX_PATH</code> to locate the Qt libraries:</p>

    <pre><code class="language-python"> # Paths to depedencies
 set(CMAKE_PREFIX_PATH 
     "${DEPENDENCY_FOLDER}/some_library/" 
     "path/to/Qt/6.5.3/mingw_64/lib/cmake/Qt6"
 )
</code></pre>
  </li>
  <li>
    <p>At the <strong>executable/library level</strong>, include the following configurations:</p>

    <pre><code class="language-python"> find_package(Qt6 REQUIRED COMPONENTS Core Gui)
    
 # Enable Qt's meta-object compiler (moc), resource compiler (rcc), and UI compiler (uic)
 set(CMAKE_AUTOMOC ON)
 set(CMAKE_AUTORCC ON)
 set(CMAKE_AUTOUIC ON)
    
 # Define Qt version macros
 add_definitions(-DQT_VERSION_MAJOR=${Qt6_VERSION_MAJOR})
 add_definitions(-DQT_VERSION_MINOR=${Qt6_VERSION_MINOR})
 add_definitions(-DQT_VERSION_PATCH=${Qt6_VERSION_PATCH})
</code></pre>
  </li>
  <li>
    <p>Next, add all what is dependent on MOC, RCC, UIC. and so on</p>

    <pre><code class="language-python"> add_executable(MyApp)
    
 # Declare it as a GUI application (disable console)
 set_target_properties(MyApp PROPERTIES 
     WIN32_EXECUTABLE TRUE 
     MACOSX_BUNDLE TRUE
 )
    
 # Link against Qt6 Components
 target_link_libraries(MyApp PRIVATE Qt6::Core Qt6::Gui)
</code></pre>
  </li>
  <li>
    <p>Only then, set up the <strong>executable</strong>:</p>

    <pre><code class="language-python"> # Add sources and headers
 target_sources(experiment_01 PRIVATE 
     source/main.cpp 
     include/MyApp.h    # Also headers with QObject
 )
    
 # Specify include directories
 target_include_directories(experiment_01 PRIVATE include)
</code></pre>
  </li>
</ol>

<h3 id="linking-libraries">Linking Libraries</h3>

<ul>
  <li>For platform-specific libraries, copy the necessary plugins (e.g., <code class="language-plaintext highlighter-rouge">qwindows.dll</code>) to the <code class="language-plaintext highlighter-rouge">platform</code> directory in your binary.</li>
</ul>

<pre><code class="language-sh">path/to/Qt/6.5.3/mingw_64/plugins/platforms
</code></pre>

<p>If you are on Windows, Copy <code class="language-plaintext highlighter-rouge">qwindows.dll</code></p>

<ul>
  <li>Core Qt components such as <code class="language-plaintext highlighter-rouge">Qt6Core.dll</code>, <code class="language-plaintext highlighter-rouge">Qt6Widgets.dll</code>, and <code class="language-plaintext highlighter-rouge">Qt6Gui.dll</code> can be found in:</li>
</ul>

<pre><code class="language-sh">path/to/Qt/6.5.3/mingw_64/bin
</code></pre>

<h3 id="integration-of-qt6-on-ubuntu">Integration of Qt6 on Ubuntu</h3>

<p>To integrate <strong>Qt6</strong> on <strong>Ubuntu</strong>, follow these steps:</p>

<ol>
  <li>
    <p><strong>Install Qt6</strong>: On Ubuntu, you can use the system’s package manager to install the necessary development packages for Qt6.</p>

    <pre><code class="language-sh"> sudo apt-get install qt6-base-dev qt6-tools-dev-tools qt6-tools-dev qt6-base-dev-tools
</code></pre>

    <p>This will install the Qt6 Core, Gui, and other essential components.</p>
  </li>
  <li>
    <p><strong>Set Up CMake for Qt6</strong>: Once Qt6 is installed, configure your <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> to find and link the necessary Qt6 components.</p>
  </li>
</ol>

<h3 id="deploying-qt6-applications-on-ubuntu">Deploying Qt6 Applications on Ubuntu</h3>

<p>To ensure your Qt6 application runs smoothly on Ubuntu, you might need to ensure that the correct <strong>Qt6 libraries</strong> and <strong>plugins</strong> are packaged with your application. For development purposes, the necessary libraries will usually be located automatically through CMake, but for deployment, you may need to package or point to the correct Qt paths manually.</p>

<p>For <strong>Qt6</strong> deployment, use the <code class="language-plaintext highlighter-rouge">qt6-deploy</code> tool, available as part of the Qt6 installation, to gather all the necessary components and bundle them with your application.</p>

<pre><code class="language-sh">qt6-deploy MyApp
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>In this guide, we have covered the essential steps to seamlessly integrate some of the most widely-used C++ libraries into your projects using CMake. From <strong>Google Test</strong> for unit testing, <strong>Google Benchmark</strong> for performance measurement, <strong>OpenCV</strong> for computer vision, to <strong>GStreamer</strong> for multimedia handling, and <strong>Qt6</strong> for building cross-platform graphical applications, this guide provides a structured approach to handling dependencies.</p>]]></content><author><name></name></author><category term="Software-Development" /><category term="Cmake" /><category term="Software" /><category term="C++" /><category term="Cmake" /><category term="Windows" /><summary type="html"><![CDATA[In modern C++ development, CMake is an indispensable tool for managing project dependencies. This comprehensive guide empowers you to effortlessly integrate widely used C++ libraries into your projects using the versatile CMake build system.]]></summary></entry><entry><title type="html">CMake - Installation On Windows</title><link href="http://localhost:4000/posts/CMake-On-Windows/" rel="alternate" type="text/html" title="CMake - Installation On Windows" /><published>2023-09-19T16:18:00+02:00</published><updated>2023-09-19T16:18:00+02:00</updated><id>http://localhost:4000/posts/CMake-On-Windows</id><content type="html" xml:base="http://localhost:4000/posts/CMake-On-Windows/"><![CDATA[<p>Here is a quick way to get started into development with CMake on Windows x64.</p>

<h2 id="getting-started">Getting Started</h2>

<h3 id="downloads">Downloads</h3>

<ul>
  <li>Download MinGW64 (posix, seh, msvcrt) from <a href="https://github.com/niXman/mingw-builds-binaries/releases">here</a>.</li>
  <li>Download CMake (Windows x64) from <a href="https://cmake.org/download/">here</a>.</li>
</ul>

<hr />

<h3 id="installation">Installation</h3>

<ul>
  <li>Install CMake in <code class="language-plaintext highlighter-rouge">C:\Program Files\Cmake</code>.</li>
  <li>Copy the <code class="language-plaintext highlighter-rouge">minGW64</code> folder into <code class="language-plaintext highlighter-rouge">C:\</code>.</li>
  <li>Add the following binary paths to the <code class="language-plaintext highlighter-rouge">PATH</code> variable:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">C:\minGW64\bin</code></li>
      <li><code class="language-plaintext highlighter-rouge">C:\Program Files\Cmake\bin</code></li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="first-project">First Project</h3>

<ul>
  <li>The simplest project to build is a <code class="language-plaintext highlighter-rouge">Hello world</code> program. Hence we will add a <code class="language-plaintext highlighter-rouge">main.cpp</code> source:</li>
</ul>

<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    std::cout &lt;&lt; "Hello World!\n";
    return 0;
}
</code></pre>

<ul>
  <li>The corresponding <code class="language-plaintext highlighter-rouge">cmake</code> instruction would be the file <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>:</li>
</ul>

<pre><code class="language-cpp">cmake_minimum_required(VERSION 3.10)

# Project Name
project(HelloWorld)

# Add an executable with sources
add_executable(
    ${PROJECT_NAME} main.cpp
)
</code></pre>

<ul>
  <li>To build the project now you should run the following commands</li>
</ul>

<pre><code class="language-sh"># compile
mkdir build
cd build
cmake .. -G "MinGW Makefiles"   # Makefile for minGW
mingw32-make

# clean
cd ..
rmdir /s /q build
</code></pre>

<h2 id="more">More</h2>

<ul>
  <li>Check out the <a href="/posts/CMake-Brief-Reference/">CMake Brief reference</a> for an overview of the commands.</li>
  <li>Check out <a href="/posts/CMake-Integrating-C++-Libraries/">how to integrate various C++ libraries</a>.</li>
  <li>Check out <a href="/posts/CMake-Production/">how to publish your own CMake Library professionally</a>.</li>
</ul>]]></content><author><name></name></author><category term="Software-Development" /><category term="Cmake" /><category term="Software" /><category term="C++" /><category term="Cmake" /><category term="Windows" /><summary type="html"><![CDATA[Here is a quick way to get started into development with CMake on Windows x64.]]></summary></entry><entry><title type="html">CMake - Brief Reference</title><link href="http://localhost:4000/posts/CMake-Brief-Reference/" rel="alternate" type="text/html" title="CMake - Brief Reference" /><published>2023-09-19T15:12:00+02:00</published><updated>2023-09-19T15:12:00+02:00</updated><id>http://localhost:4000/posts/CMake-Brief%20Reference</id><content type="html" xml:base="http://localhost:4000/posts/CMake-Brief-Reference/"><![CDATA[<p>CMake is a powerful and flexible build system generator that supports the creation of makefiles, project files, and build environments across various platforms and compilers. Below is a brief reference guide to some essential commands and patterns commonly used in CMake.</p>

<h2 id="key-commands-and-concepts">Key Commands and Concepts</h2>

<h3 id="project-definition">Project Definition</h3>

<p>CMake allows for detailed configuration of your project. Below are different levels of project definition:</p>

<ul>
  <li><strong>Basic Project Definition</strong>: Defines the project name.</li>
</ul>

<pre><code class="language-cpp">project(MyProjectName)
</code></pre>

<ul>
  <li><strong>Project with Versioning</strong>: Specifies the project name along with its version.</li>
</ul>

<pre><code class="language-cpp">project(MyProjectName VERSION 1.0.0)
</code></pre>

<ul>
  <li><strong>Comprehensive Project Configuration</strong>: Provides additional details such as the languages used, a brief description, and a homepage URL.</li>
</ul>

<pre><code class="language-cpp">project(
  MyProjectName 
  VERSION 1.0.0
  LANGUAGES C CXX ASM Fortran CUDA
  DESCRIPTION "This is a sample project"
  HOMEPAGE_URL "https://example.com"
)
</code></pre>

<h2 id="variables">Variables</h2>

<p>Variables in CMake are fundamental for managing values and passing data throughout the <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> files.</p>

<h3 id="definition">Definition</h3>

<ul>
  <li><strong>Basic Variable</strong>: Sets a variable with a specified value. Scoping can be controlled by specifying the parent scope.</li>
</ul>

<pre><code class="language-cpp">set(VARIABLE_NAME "Value")                  # local scope
set(VARIABLE_NAME "Value" PARENT_SCOPE)     # parent scope
</code></pre>

<ul>
  <li><strong>List Variable</strong>: Commonly used for defining lists of source files.</li>
</ul>

<pre><code class="language-cpp">set(SOURCES main.cpp MyClass.cpp AnotherClass.cpp)
</code></pre>

<h3 id="appending-to-variables">Appending to Variables</h3>

<ul>
  <li><strong>Appending Values</strong>: Adds new values to an existing list.</li>
</ul>

<pre><code class="language-cpp">set(SOURCES ${SOURCES} YetAnotherClass.cpp) # Traditional way
list(APPEND SOURCES YetAnotherClass.cpp)    # using APPEND
</code></pre>

<h2 id="executable-configuration">Executable Configuration</h2>

<p>Defining and managing executables within your project can be easily achieved through CMake:</p>

<ul>
  <li><strong>Basic Executable</strong>: Defines an executable from a single source file.</li>
</ul>

<pre><code class="language-cpp">add_executable(my_executable main.cpp)
</code></pre>

<ul>
  <li><strong>Multiple Source Files</strong>: Creates an executable from multiple source files.</li>
</ul>

<pre><code class="language-c">add_executable(my_executable ${SOURCES})
</code></pre>

<ul>
  <li><strong>Conditional Source Files</strong>: Dynamically adds source files based on platform or other conditions.</li>
</ul>

<pre><code class="language-c">if(WIN32)
    list(APPEND SOURCES win_main.cpp)
else()
    list(APPEND SOURCES unix_main.cpp)
endif()

add_executable(my_app ${SOURCES})
</code></pre>

<ul>
  <li><strong>Setting Executable Properties</strong>: Configures specific properties, such as the C++ standard required.</li>
</ul>

<pre><code class="language-c">add_executable(my_app main.cpp)
set_target_properties(my_app PROPERTIES
    CXX_STANDARD 11
    CXX_STANDARD_REQUIRED YES
    CXX_EXTENSIONS NO
)
</code></pre>

<h2 id="including-directories">Including Directories</h2>

<p>CMake offers flexible methods to manage include directories, ensuring that the compiler can locate the necessary header files:</p>

<ul>
  <li><strong>Global Include Directory</strong>: This approach sets include directories globally, but it is generally discouraged due to its potential to introduce conflicts.</li>
</ul>

<pre><code class="language-c">include_directories(${CMAKE_SOURCE_DIR}/include)    # bad practice
</code></pre>

<ul>
  <li><strong>Target-Specific Include Directory</strong>: Specifies include directories for a specific target, promoting better encapsulation and avoiding global scope issues.</li>
</ul>

<pre><code class="language-c">add_executable(my_app main.cpp)
target_include_directories(my_app PRIVATE ${CMAKE_SOURCE_DIR}/include)
</code></pre>

<h2 id="library-management">Library Management</h2>

<p>Libraries are crucial in C++ projects, and CMake provides robust commands for adding and linking libraries effectively:</p>

<h3 id="adding-libraries">Adding Libraries</h3>

<ul>
  <li><strong>Static Library</strong>: Creates a static library from specified source files.</li>
</ul>

<pre><code class="language-cpp">add_library(my_static_lib STATIC src/lib.cpp)
</code></pre>

<ul>
  <li><strong>Shared Library</strong>: Creates a shared library.</li>
</ul>

<pre><code class="language-c">add_library(my_shared_lib SHARED src/lib.cpp)
</code></pre>

<ul>
  <li><strong>Module Library</strong>: Creates a library that is loaded dynamically at runtime.</li>
</ul>

<pre><code class="language-c">add_library(my_shared_lib MODULE src/lib.cpp)
</code></pre>

<ul>
  <li><strong>Object Library</strong>: Compiles sources into object files without archiving or linking them into a library.</li>
</ul>

<pre><code class="language-c">add_library(my_shared_lib OBJECT src/lib.cpp)
</code></pre>

<h3 id="linking-libraries">Linking Libraries</h3>

<ul>
  <li><strong>Linking to an Executable</strong>: Links a library to an executable.</li>
</ul>

<pre><code class="language-c">add_executable(my_app main.cpp)
add_library(my_lib STATIC src/lib.cpp)
target_link_libraries(my_app PRIVATE my_lib)
</code></pre>

<ul>
  <li><strong>Linking System Libraries</strong>: Links against a system-provided library.</li>
</ul>

<pre><code class="language-c">find_library(MATH_LIB m)
if(MATH_LIB)
    target_link_libraries(my_app PRIVATE ${MATH_LIB})
endif()
</code></pre>

<ul>
  <li><strong>Importing External Libraries</strong>: Allows the use of an external library in your project.</li>
</ul>

<pre><code class="language-cpp">add_library(external_lib UNKNOWN IMPORTED)
set_target_properties(external_lib PROPERTIES
  IMPORTED_LOCATION "/path/to/external_lib.a"
  INTERFACE_INCLUDE_DIRECTORIES "/path/to/includes"
)
</code></pre>

<ul>
  <li><strong>Known Libraries</strong>: Examples of linking against some well-known libraries. (Examples for Threads, Catch2, OpenCV, Google Benchmark, and Eigen provided)</li>
</ul>

<h4 id="predefined-variables">Predefined Variables</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">CMAKE_SOURCE_DIR</code></strong>: The top-level source directory.</li>
</ul>

<pre><code class="language-cpp">message("Top-level source directory: ${CMAKE_SOURCE_DIR}")
</code></pre>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">CMAKE_BINARY_DIR</code></strong>: The top-level build directory (usually the directory where you invoked CMake).</li>
</ul>

<pre><code class="language-cpp">message("Binary directory: ${CMAKE_BINARY_DIR}")
</code></pre>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">CMAKE_CURRENT_SOURCE_DIR</code></strong>: The source directory of the current CMakeLists.txt.</li>
</ul>

<pre><code class="language-cpp">include(${CMAKE_CURRENT_SOURCE_DIR}/extra.cmake)
</code></pre>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">CMAKE_CURRENT_BINARY_DIR</code></strong>: The build directory corresponding to the current source directory.</li>
</ul>

<pre><code class="language-cpp">set(EXECUTABLE_OUTPUT_PATH ${CMAKE_CURRENT_BINARY_DIR}/bin)
</code></pre>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">CMAKE_PROJECT_NAME</code></strong>: The name of the first project set in the top-level CMakeLists.txt.</li>
</ul>

<pre><code class="language-c">message("Top level project: ${CMAKE_PROJECT_NAME}")
</code></pre>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">CMAKE_CXX_COMPILER</code></strong>: The full path to the C++ compiler.</li>
</ul>

<pre><code class="language-c">message("Using compiler: ${CMAKE_CXX_COMPILER}")
</code></pre>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">CMAKE_C_COMPILER</code></strong>: The full path to the C++ compiler.</li>
</ul>

<pre><code class="language-c">message("Using compiler: ${CMAKE_C_COMPILER}")
</code></pre>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">CMAKE_PREFIX_PATH</code></strong>: Directories to be searched by <code class="language-plaintext highlighter-rouge">find_package()</code> before its default paths.</li>
</ul>

<pre><code class="language-cpp">list(APPEND CMAKE_PREFIX_PATH "/custom/path")
</code></pre>

<h2 id="installation">Installation</h2>

<p>CMake provides a flexible <code class="language-plaintext highlighter-rouge">install()</code> command that allows you to specify which files should be installed and where they should go. This is useful for deploying your project after it has been built.</p>

<h3 id="basic-install-command">Basic Install Command</h3>

<p>To install a target, such as a library or an executable, you can use the <code class="language-plaintext highlighter-rouge">install()</code> command in your <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>:</p>

<pre><code class="language-cpp"># Install an executable
install(TARGETS my_executable DESTINATION bin)

# Install a library
install(TARGETS my_library
        ARCHIVE DESTINATION lib
        LIBRARY DESTINATION lib
        RUNTIME DESTINATION bin)
</code></pre>

<h3 id="installing-header-files">Installing Header Files</h3>

<p>You can also install header files using the <code class="language-plaintext highlighter-rouge">install()</code> command:</p>

<pre><code class="language-cpp">install(FILES my_header.h DESTINATION include)
</code></pre>

<h3 id="directory-installation">Directory Installation</h3>

<p>If you have multiple header files in a directory, you can install them all at once:</p>

<pre><code class="language-cpp">install(DIRECTORY include/ DESTINATION include)
</code></pre>

<h3 id="full-installation-example">Full Installation Example</h3>

<p>Here’s an example that combines everything:</p>

<pre><code class="language-cpp">project(MyProject)

add_executable(my_executable main.cpp)
add_library(my_library STATIC my_library.cpp)

install(TARGETS my_executable my_library
        RUNTIME DESTINATION bin
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib)

install(FILES my_header.h DESTINATION include)
install(DIRECTORY include/ DESTINATION include)
</code></pre>

<h3 id="running-the-install-command">Running the Install Command</h3>

<p>To install the targets and files as specified, you can run the following CMake command after building:</p>

<pre><code class="language-bash">cmake --install build
</code></pre>

<p>This will copy the built executables, libraries, and header files to the directories specified in your <code class="language-plaintext highlighter-rouge">install()</code> commands.</p>

<p>By understanding and utilizing these commands and best practices, developers can efficiently manage their C++ projects with CMake, ensuring scalability, maintainability, and cross-platform compatibility.</p>]]></content><author><name></name></author><category term="Software-Development" /><category term="Cmake" /><category term="Software" /><category term="C++" /><category term="Cmake" /><category term="Reference" /><summary type="html"><![CDATA[CMake is a powerful and flexible build system generator that supports the creation of makefiles, project files, and build environments across various platforms and compilers. Below is a brief reference guide to some essential commands and patterns commonly used in CMake.]]></summary></entry><entry><title type="html">The Black Pill (STM32F411CEU6)</title><link href="http://localhost:4000/posts/BlackPill-STM32F411CEU6/" rel="alternate" type="text/html" title="The Black Pill (STM32F411CEU6)" /><published>2023-05-17T13:41:00+02:00</published><updated>2023-05-17T13:41:00+02:00</updated><id>http://localhost:4000/posts/BlackPill-STM32F411CEU6</id><content type="html" xml:base="http://localhost:4000/posts/BlackPill-STM32F411CEU6/"><![CDATA[<div style="display: flex; flex-wrap: wrap; align-items: center;">
  <div style="flex: 0 0 auto; min-width: 200px;">
    <p><img src="https://i0.wp.com/github.com/WeActStudio/WeActStudio.MiniSTM32F4x1/raw/master/images/STM32F4x1-V30_3D.jpg?ssl=1" alt="Description of the image" style="float: right; margin-right: 15px; width: 250px;" /></p>
  </div>
  <div style="flex: 1; min-width: 200px;">

    <p>In this article, we will get you started with the STM32F411CE board (aka the black pill). For a complete overview of the board <a href="https://stm32-base.org/boards/STM32F411CEU6-WeAct-Black-Pill-V2.0.html">see this</a>.</p>

    <p>This chip is based on ARM Cortex-M4 32-Bit Architecture with clock frequency of 100 MHz RAM of 512KB.</p>

    <p>This chip is manufactured by the Dutch company STMicroelectronics, which is based in Switzerland. The company provides several tools to develop for their chips. The official IDE is called the <a href="https://www.st.com/en/development-tools/stm32cubeide.html">STM32CUBE IDE</a> which is used for this quick tutorial.</p>

  </div>
</div>

<h2 id="getting-started">Getting Started</h2>

<h3 id="overview">Overview</h3>

<p>The illustration below demonstrates the characteristics of the pins on the board.</p>

<p><img src="https://i0.wp.com/github.com/WeActStudio/WeActStudio.MiniSTM32F4x1/raw/master/images/STM32F4x1_PinoutDiagram_RichardBalint.png?ssl=1" alt="The pins diagram of the chip/board." /></p>

<h3 id="requirements">Requirements</h3>

<ol>
  <li>
    <p><strong>Development Environment</strong>: You can choose either of the following:</p>

    <ul>
      <li><strong>STM32Cube IDE</strong>:</li>
    </ul>

    <p>This is the official STM32 IDE and it includes build environment. you can download it from <a href="https://www.st.com/en/development-tools/stm32cubeide.html">here</a>.</p>

    <ul>
      <li>
        <p><strong>CMake and Custom IDE</strong>:</p>

        <p>Assuming you have CMake installed.</p>

        <ol>
          <li>
            <p>Download the <em>GNU Arm Embedded Toolchain</em> from <a href="https://developer.arm.com/downloads/-/gnu-rm">here</a> and add it to <code class="language-plaintext highlighter-rouge">PATH</code>. This is important to compile the project.</p>
          </li>
          <li>
            <p>Download the <em>OpenOCD</em> from <a href="https://gnutoolchains.com/arm-eabi/openocd/">here</a> and add it to <code class="language-plaintext highlighter-rouge">PATH</code>. This is important for debugging.</p>
          </li>
          <li>
            <p>Download the <strong>STM32CubeMX</strong> from <a href="https://www.st.com/en/development-tools/stm32cubemx.html">here</a> and add it to <code class="language-plaintext highlighter-rouge">PATH</code>. This is important to generate the project files along HAL library.</p>
          </li>
        </ol>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>STM32 Cube Programmer</strong>: To upload the binary to the chip. You can download it from <a href="https://www.st.com/en/development-tools/stm32cubeprog.html">here</a>.</p>
  </li>
</ol>

<h3 id="setting-up-the-environment">Setting up the environment</h3>

<h3 id="setting-up-the-clock">Setting Up the Clock</h3>

<p>Set <code class="language-plaintext highlighter-rouge">HSE</code> and <code class="language-plaintext highlighter-rouge">LSE</code> to crystal clock on the <code class="language-plaintext highlighter-rouge">RCC</code>. Now we will configure the clock depending on the chip. For example, the <code class="language-plaintext highlighter-rouge">STM32F411CEUx</code> from <em>Weact</em> is connected to a $32.786$ kHz resonator on the LSE and a 25 MHz resonator on the HSE, so the configuration diagram should be like this:</p>

<ul>
  <li>Set <em>PPL Source Mux</em> to <em>HSE</em></li>
  <li>Set <code class="language-plaintext highlighter-rouge">/M</code> = <code class="language-plaintext highlighter-rouge">/ 25</code></li>
  <li>Set <code class="language-plaintext highlighter-rouge">*N</code> = <code class="language-plaintext highlighter-rouge">X 192</code></li>
  <li>Set <code class="language-plaintext highlighter-rouge">/Q</code> = <code class="language-plaintext highlighter-rouge">/ 4</code></li>
  <li>Set <code class="language-plaintext highlighter-rouge">/P</code> = <code class="language-plaintext highlighter-rouge">/ 2</code></li>
  <li>Set <em>System Clock Mux</em> to <em>PLLCLK</em></li>
  <li>Set <code class="language-plaintext highlighter-rouge">AHB Prescaler</code> = <code class="language-plaintext highlighter-rouge">/ 1</code></li>
</ul>

<p>Notice that the STM32F411CEUx supports up to 100 MHz clocking, but since the Universal Serial Bus On-The-Go Full Speed (USB_OTG_FS) requires a dedicated 48 MHz clock (datasheet 3.27), the clock responsible for this (48 MHz clocks) comes from the Main PLL directly. By clocking the HCLK to 96 MHz, we can achieve a division that results in 48 MHz for this clock.</p>

<h2 id="project-structure">Project Structure</h2>

<!-- TODO: Starting the project -->

<h3 id="project-settings-myprojectioc">Project Settings (<code class="language-plaintext highlighter-rouge">myproject.ioc</code>)</h3>

<p>This file defines the settings of the chip when it starts, and the necessary code is re-generated whenever this file is updated. From here, you can set the initial mode of the pins (input. output, etc…), Direct Memory Access (DMA) settings, timers and more.</p>

<h3 id="linker-script-stm32f411ceu6_flashld">Linker Script (<code class="language-plaintext highlighter-rouge">STM32F411CEU6_FLASH.ld</code>)</h3>

<p>Let’s take a look at the linker script generated by STM32 Cube MX:</p>

<pre><code class="language-c">/* Entry Point */
ENTRY(Reset_Handler)

/* Highest address of the user mode stack */
_estack = ORIGIN(RAM) + LENGTH(RAM);    /* end of RAM */
/* Generate a link error if heap and stack don't fit into RAM */
_Min_Heap_Size = 0x200;      /* required amount of heap  */
_Min_Stack_Size = 0x400; /* required amount of stack */

/* Specify the memory areas */
MEMORY
{
RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 20K
FLASH (rx)     : ORIGIN = 0x08000000, LENGTH = 64K
}
/* ... */
</code></pre>

<p>In the linker script (<code class="language-plaintext highlighter-rouge">STM32F411CEU6_FLASH.ld</code>), the <code class="language-plaintext highlighter-rouge">ENTRY(Reset_Handler)</code> directive specifies this entry point.</p>

<p>The <code class="language-plaintext highlighter-rouge">Reset_Handler</code> is the entry point for the program and is defined in the assembly file <code class="language-plaintext highlighter-rouge">startup_stm32f103xb.s</code>.</p>

<ul>
  <li>It is responsible for initializing the system and preparing the execution environment before jumping to the main application code.</li>
  <li>When the microcontroller is reset, the <code class="language-plaintext highlighter-rouge">Reset_Handler</code> is the first function that gets executed as specified in the above linker.</li>
  <li>This handler is crucial in setting up the system by configuring the stack pointer, initializing data segments, and calling the <code class="language-plaintext highlighter-rouge">main()</code> function.</li>
</ul>

<h4 id="memory-layout">Memory Layout</h4>

<p>The memory configuration is defined in the linker script under the <code class="language-plaintext highlighter-rouge">MEMORY</code> section. This section specifies the start addresses and lengths of different memory regions in the microcontroller:</p>

<ul>
  <li><strong>RAM</strong>: The RAM region is defined with a starting address of <code class="language-plaintext highlighter-rouge">0x20000000</code> and a length of 20KB. This is the area where the runtime data (variables, stack, and heap) will be stored.</li>
  <li><strong>FLASH</strong>: The FLASH region, starting at <code class="language-plaintext highlighter-rouge">0x08000000</code> with a length of 64KB, is used to store the program code and constants.</li>
</ul>

<h4 id="stack-and-heap-configuration">Stack and Heap Configuration</h4>

<ul>
  <li>
    <p><strong>_estack</strong>: The <code class="language-plaintext highlighter-rouge">_estack</code> symbol defines the highest address of the stack in RAM. It is calculated as the sum of the starting address of RAM (<code class="language-plaintext highlighter-rouge">ORIGIN(RAM)</code>) and the total length of RAM (<code class="language-plaintext highlighter-rouge">LENGTH(RAM)</code>).
This ensures that the stack starts at the end of the available RAM space and grows downwards.</p>
  </li>
  <li>
    <p><strong>_Min_Heap_Size</strong>: This value specifies the minimum required heap size, which is set to <code class="language-plaintext highlighter-rouge">0x200</code> (512 bytes).
The heap is used for dynamic memory allocation during runtime.</p>
  </li>
  <li>
    <p><strong>_Min_Stack_Size</strong>: This value defines the minimum required stack size, set to <code class="language-plaintext highlighter-rouge">0x400</code> (1024 bytes).
The stack is used for storing local variables and function call information during execution.</p>
  </li>
</ul>

<p>These values ensure that the heap and stack have enough space within the RAM, preventing overlap and potential runtime errors. The linker script will generate an error if the specified heap and stack sizes do not fit within the defined RAM area.</p>

<h3 id="c-entry-file-coresrcmainc">C Entry File (<code class="language-plaintext highlighter-rouge">core/Src/main.c</code>)</h3>

<p>This is the main source code, where the entry function resides. Also, this is place where most of the generated code done by the IDE is written after updating <em>myproject.ioc</em>.</p>

<p>We will look into two important functions here.</p>

<h4 id="static-void-mx_gpio_initvoid">static void MX_GPIO_Init(void)</h4>

<p>This function sets up the initial settings for the IO pins of the chip. On the board the blue LED is connected to pin C13. If we set this pin mode to GPIO_Output mode in the <em>myproject.ioc</em> file, as in the illustration below</p>

<p><img src="/assets/images/embedded/stm32_cubemx/GPIO_configuration_stm32f411ceux.webp" alt="GPIO Configuration of STM32F4CEUx series on STM32 CubeMX" /></p>

<p>Figure 2: Configuring the chip’s pins</p>

<p>we can see that the IDE has generated the following code in the function MX_GPIO_Init:</p>

<pre><code class="language-cpp">GPIO_InitTypeDef GPIO_InitStruct = {0};

/* GPIO Ports Clock Enable */
__HAL_RCC_GPIOC_CLK_ENABLE();

/*Configure GPIO pin Output Level */
HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);

/*Configure GPIO pin : PC13 */
GPIO_InitStruct.Pin = GPIO_PIN_13;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct);
</code></pre>

<p>Lines from 9 to 14 are responsible for initializing the pin C13. We can see in line that the HAL library provides the function <code class="language-plaintext highlighter-rouge">HAL_GPIO_Init</code> which takes first the name of the Pins block and then a pointer to a structure <code class="language-plaintext highlighter-rouge">GPIO_InitTypeDef</code>. This is also how the pin settings is changed programmatically. The details of the pins settings are explained in the following section.</p>

<hr />

<p>The <strong>Pull</strong> variable specifies which resistors should be connected to the pin. The possible configurations are</p>

<ul>
  <li>Pull down (<code class="language-plaintext highlighter-rouge">GPIO_PULLDOWN</code>)</li>
  <li>Pull up (<code class="language-plaintext highlighter-rouge">GPIO_PULLUP</code>)</li>
  <li>No resistor (<code class="language-plaintext highlighter-rouge">GPIO_NOPULL</code>)</li>
</ul>

<p>The pull down resistor connects the pin to the ground, while the pull up resistor connects the pin to 3.3V.</p>

<hr />

<h2 id="uploading-firmware">Uploading Firmware</h2>

<p>Uploading firmware to an STM32 microcontroller can be achieved using different interfaces such as DFU (Device Firmware Upgrade) or UART. Below are the steps for using both methods with the <em>WeAct</em> Black Pill board.</p>

<h3 id="using-dfu-mode">Using DFU Mode</h3>

<p>To upload the firmware via DFU mode, connect your device via USB and use the following command:</p>

<pre><code class="language-bash">STM32_Programmer_CLI -c port=usb1 -w \Debug\app.bin 0x08000000
</code></pre>

<ul>
  <li><code class="language-plaintext highlighter-rouge">port=usb1</code>: Specifies the USB port.</li>
  <li><code class="language-plaintext highlighter-rouge">-w \Debug\app.bin</code>: Indicates the path to the binary file.</li>
  <li><code class="language-plaintext highlighter-rouge">0x08000000</code>: Specifies the start address in the flash memory.</li>
</ul>

<h3 id="using-uart">Using UART</h3>

<p>To upload the firmware via UART, use the following command:</p>

<pre><code class="language-bash">STM32_Programmer_CLI -c port=COM10 -w \Debug\app.elf
</code></pre>

<ul>
  <li><code class="language-plaintext highlighter-rouge">port=COM10</code>: Specifies the COM port.</li>
  <li><code class="language-plaintext highlighter-rouge">-w \Debug\app.elf</code>: Indicates the path to the ELF file.</li>
</ul>

<p>To reset and disable the read protection of the microcontroller, you can use:</p>

<pre><code class="language-bash">STM32_Programmer_CLI -c port=COM10 -rdu
</code></pre>

<hr />

<h2 id="working-with-gpios">Working with GPIOs</h2>

<p>GPIO (General Purpose Input/Output) is crucial for interfacing with the STM32 microcontroller’s pins. Below is an overview of how to configure and use GPIOs.</p>

<h3 id="gpio-initialization-gpio_inittypedef">GPIO Initialization (<code class="language-plaintext highlighter-rouge">GPIO_InitTypeDef</code>)</h3>

<p><code class="language-plaintext highlighter-rouge">GPIO_InitTypeDef</code> is a structure used to define the specifications of a GPIO pin. Below are the key fields in this structure:</p>

<pre><code class="language-cpp">typedef struct  
{  
  uint32_t Pin;
  uint32_t Mode
  uint32_t Pull;
  uint32_t Speed;  
  uint32_t Alternate; // Only available in &gt;= Cortex-M4
} GPIO_InitTypeDef;
</code></pre>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">Pin</code>:</strong> Specifies the GPIO pins to be configured. Multiple pins can be selected using a bitwise OR operation. Example: <code class="language-plaintext highlighter-rouge">(GPIO_PIN_0 | GPIO_PIN_1)</code>.
  Mask of the pin, <code class="language-plaintext highlighter-rouge">(GPIO_PIN_0 = 0x0001)</code>, <code class="language-plaintext highlighter-rouge">(GPIO_PIN_1 = 0x0002)</code>…</p>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">Mode</code>:</strong> Defines the operating mode for the selected pins. The following modes are available:
    <ol>
      <li>Input Mode
        <ul>
          <li><code class="language-plaintext highlighter-rouge">GPIO_MODE_INPUT:</code> Input Floating Mode
            <blockquote>
              <p>The <strong>input</strong> mode changes a variable variable according to the voltage applied to the pin (Note this should never exceed 3.3V for most pins).</p>
            </blockquote>
          </li>
        </ul>
      </li>
      <li>Output Mode
        <ul>
          <li><code class="language-plaintext highlighter-rouge">GPIO_MODE_OUTPUT_PP:</code> Output Push-Pull
            <blockquote>
              <p>The <strong>push-pull mode</strong> sets up the pin for a single direction output. The pin state, can either be high or low.</p>
            </blockquote>
          </li>
          <li><code class="language-plaintext highlighter-rouge">GPIO_MODE_OUTPUT_OD:</code> Output Open Drain
            <blockquote>
              <p>The <strong>open-drain mode</strong>, sets up the pin to accept bidirectional input and output. (For more <a href="https://open4tech.com/open-drain-output-vs-push-pull-output/">see this article</a>).</p>
            </blockquote>
          </li>
        </ul>
      </li>
      <li>Alternate Function
        <ul>
          <li><code class="language-plaintext highlighter-rouge">GPIO_MODE_AF_PP:</code> Push-Pull</li>
          <li><code class="language-plaintext highlighter-rouge">GPIO_MODE_AF_OD:</code> Open Drain</li>
        </ul>
      </li>
      <li>Analog Mode
        <ul>
          <li><code class="language-plaintext highlighter-rouge">GPIO_MODE_ANALOG:</code> Analog Mode
            <blockquote>
              <p>The <strong>analog</strong> mode allows the pin to read the voltage applied to it. However, not all pins are able to be set to this mode, in the case of this chip, these pins are A0..A7 as well as B0 and B1, which also correspond to ADC0..ADC9.
Accessing the analog value read from the pin needs additional configuration, such as direct memory access (DMA), which we will look into in the following sections.</p>
            </blockquote>
          </li>
        </ul>
      </li>
      <li>External Interrupt
        <ul>
          <li><code class="language-plaintext highlighter-rouge">GPIO_MODE_IT_RISING:</code> Rising Edge</li>
          <li><code class="language-plaintext highlighter-rouge">GPIO_MODE_IT_FALLING:</code> Falling Edge</li>
          <li><code class="language-plaintext highlighter-rouge">GPIO_MODE_IT_RISING_FALLING:</code> Rising and Falling Edge</li>
        </ul>
      </li>
      <li>External Event
        <ul>
          <li><code class="language-plaintext highlighter-rouge">GPIO_MODE_EVT_RISING:</code> Rising Edge</li>
          <li><code class="language-plaintext highlighter-rouge">GPIO_MODE_EVT_FALLING:</code> Falling Edge</li>
          <li><code class="language-plaintext highlighter-rouge">GPIO_MODE_EVT_RISING_FALLING:</code> Rising and Falling Edge</li>
        </ul>
      </li>
    </ol>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">Pull</code>:</strong> Specifies the internal pull-up or pull-down resistor activation:
    <ol>
      <li><code class="language-plaintext highlighter-rouge">GPIO_NOPULL</code>: No pull-up or pull-down activation.</li>
      <li><code class="language-plaintext highlighter-rouge">GPIO_PULLUP</code>: Pull-up resistor activation.</li>
      <li><code class="language-plaintext highlighter-rouge">GPIO_PULLDOWN</code>: Pull-down resistor activation.</li>
    </ol>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">Speed</code>:</strong> Defines the speed for the GPIO pin:
    <ol>
      <li><code class="language-plaintext highlighter-rouge">GPIO_SPEED_FREQ_LOW</code>: 2 MHz.</li>
      <li><code class="language-plaintext highlighter-rouge">GPIO_SPEED_FREQ_MEDIUM</code>: 12.5 to 50 MHz.</li>
      <li><code class="language-plaintext highlighter-rouge">GPIO_SPEED_FREQ_HIGH</code>: 25 to 100 MHz.</li>
      <li><code class="language-plaintext highlighter-rouge">GPIO_SPEED_FREQ_VERY_HIGH</code>: 50 to 200 MHz.</li>
    </ol>
  </li>
</ul>

<p>An example of initializing a pin:</p>

<pre><code class="language-cpp">GPIO_InitTypeDef GPIO_InitStruct = {};
GPIO_InitStruct.Pin = GPIO_PIN_13;  
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  
GPIO_InitStruct.Pull = GPIO_NOPULL;  
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;  
HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct);
</code></pre>

<h3 id="gpio-pin-states-gpio_pinstate">GPIO Pin States (<code class="language-plaintext highlighter-rouge">GPIO_PinState</code>)</h3>

<p>A GPIO pin can be in one of the following two states:</p>

<ol>
  <li><strong>Reset State (<code class="language-plaintext highlighter-rouge">GPIO_PIN_RESET</code>):</strong> Logical low (<code class="language-plaintext highlighter-rouge">0</code>).</li>
  <li><strong>Set State (<code class="language-plaintext highlighter-rouge">GPIO_PIN_SET</code>):</strong> Logical high (<code class="language-plaintext highlighter-rouge">1</code>).</li>
</ol>

<h4 id="writing-to-a-pin">Writing to a Pin</h4>

<p>To set or reset a GPIO pin, you can use the following methods:</p>

<h5 id="setting-a-pin">Setting a Pin</h5>

<pre><code class="language-c">GPIOA -&gt; BSSR = GPIO_PIN_0;                         // fast
GPIOA -&gt; ODR |= GPIO_PIN_0;                         // legacy
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET); // HAL Library
</code></pre>

<h5 id="resetting-a-pin">Resetting a Pin</h5>

<pre><code class="language-c">GPIOA -&gt; BSSR = (uint32_t)GPIO_PIN_0  &lt;&lt; 16U;         // fast
GPIOA -&gt; ODR &amp;= ~GPIO_PIN_0;                          // legacy
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_RESET); // HAL Library
</code></pre>

<p>No Masking needed for setting/resetting a pin when using BSRR register, ODR Registers stores the output values and we can use it to read the output values.</p>

<p>Note that the function <code class="language-plaintext highlighter-rouge">HAL_GPIO_WritePin</code> writes the value to the pin <strong>atomically</strong> without OR’ing it with other masks. That means interrupts do not have to be disabled.</p>

<h4 id="reading-a-pin">Reading a Pin</h4>

<p>Just like reading the Output data from ODR, we can read the input data from IDR.</p>

<pre><code class="language-c">uint8_t PA0;
PA0 = GPIOA -&gt; IDT &amp; GPIO_PIN_0;            // legacy
PA0 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);  // HAL Library
</code></pre>

<h3 id="gpio-port-configuration-gpio_typedef">GPIO Port Configuration (<code class="language-plaintext highlighter-rouge">GPIO_TypeDef</code>)</h3>

<p>Each GPIO port is represented by a <code class="language-plaintext highlighter-rouge">GPIO_TypeDef</code> structure, which contains the following registers:</p>

<pre><code class="language-cpp">typedef struct  
{  
  __IO uint32_t MODER;   // Mode Register
  __IO uint32_t OTYPER;  // Output Type Register
  __IO uint32_t OSPEEDR  // Output Speed Register
  __IO uint32_t PUPDR    // Pull-Up Pull-Down Register
  __IO uint32_t IDR;     // Input Data Register
  __IO uint32_t ODR;     // Output Data Rigister
  __IO uint32_t BSRR     // Bit Set/Reset Register
  __IO uint32_t LCKR;    // Lock Register
  __IO uint32_t AFR[2];  // Alternate Function Registers
} GPIO_TypeDef;
</code></pre>

<ol>
  <li><code class="language-plaintext highlighter-rouge">MODER</code>: Port Mode Register (offset <code class="language-plaintext highlighter-rouge">0x00</code>).
    <blockquote>
      <p>Each pin has 2 bits in this register:</p>
      <ul>
        <li><code class="language-plaintext highlighter-rouge">00</code>: Input mode</li>
        <li><code class="language-plaintext highlighter-rouge">01</code>: General-purpose output mode</li>
        <li><code class="language-plaintext highlighter-rouge">10</code>: Alternate function mode (like UART, SPI, etc.)</li>
        <li><code class="language-plaintext highlighter-rouge">11</code>: Analog mode</li>
      </ul>
    </blockquote>
  </li>
  <li><code class="language-plaintext highlighter-rouge">OTYPER</code>: Port Output Type Register (offset <code class="language-plaintext highlighter-rouge">0x04</code>).
    <blockquote>
      <p>Output Type</p>
      <ul>
        <li><code class="language-plaintext highlighter-rouge">0</code>: Output push-pull (default)</li>
        <li><code class="language-plaintext highlighter-rouge">1</code>: Output open-drain</li>
      </ul>
    </blockquote>
  </li>
  <li><code class="language-plaintext highlighter-rouge">OSPEEDR</code>: Port Output Speed Register (offset <code class="language-plaintext highlighter-rouge">0x08</code>).
    <blockquote>
      <p>Each pin has 2 bits in this register:</p>
      <ul>
        <li><code class="language-plaintext highlighter-rouge">00</code>: Low speed</li>
        <li><code class="language-plaintext highlighter-rouge">01</code>: Medium speed</li>
        <li><code class="language-plaintext highlighter-rouge">10</code>: High speed</li>
        <li><code class="language-plaintext highlighter-rouge">11</code>: Very high speed</li>
      </ul>
    </blockquote>
  </li>
  <li><code class="language-plaintext highlighter-rouge">PUPDR</code>: Port Pull-up/Pull-down Register (offset <code class="language-plaintext highlighter-rouge">0x0C</code>).
    <blockquote>
      <p>Each pin has 2 bits in this register:</p>
      <ul>
        <li><code class="language-plaintext highlighter-rouge">00</code>: No pull-up, pull-down</li>
        <li><code class="language-plaintext highlighter-rouge">01</code>: Pull-up</li>
        <li><code class="language-plaintext highlighter-rouge">10</code>: Pull-down</li>
        <li><code class="language-plaintext highlighter-rouge">11</code>: Reserved</li>
      </ul>
    </blockquote>
  </li>
  <li><code class="language-plaintext highlighter-rouge">IDR</code>: Input Data Register (offset <code class="language-plaintext highlighter-rouge">0x10</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">ODR</code>: Output Data Register (offset <code class="language-plaintext highlighter-rouge">0x14</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">BSRR</code>: Port Bit Set/Reset Register (offset <code class="language-plaintext highlighter-rouge">0x18</code>).
    <blockquote>
      <p>This 32-bit register allows <strong>atomic</strong> bit-wise operations to set or reset individual bits in the <code class="language-plaintext highlighter-rouge">ODR</code>:</p>
      <ul>
        <li>The lower 16 bits (0-15) are used to set the corresponding ODR bits.</li>
      </ul>

      <pre><code class="language-cpp">// Set Pin A0
GPIOA-&gt;BSRR = GPIO_PIN_0;
</code></pre>

      <ul>
        <li>The upper 16 bits (16-31) are used to reset the corresponding ODR bits.</li>
      </ul>

      <pre><code class="language-cpp">// Reset Pin A0
GPIOA -&gt; BSSR = (uint32_t)GPIO_PIN_0 &lt;&lt; 16U;
</code></pre>

    </blockquote>
  </li>
  <li><code class="language-plaintext highlighter-rouge">LCKR</code>: Port Configuration Lock Register (offset <code class="language-plaintext highlighter-rouge">0x1C</code>).
    <blockquote>
      <p>This 16-bit register locks the configuration of the GPIO port to prevent accidental changes</p>
      <ul>
        <li>Once locked, the configuration of the GPIO cannot be modified until the next reset.</li>
      </ul>

      <pre><code class="language-cpp">// Step 1: Write the pin's lock pattern and set LCKK bit
GPIOA-&gt;LCKR = GPIO_LCKR_LCKK | GPIO_PIN_0;

// Step 2: Write the pin's lock pattern without LCKK bit
GPIOA-&gt;LCKR = GPIO_PIN_0;

// Step 3: Write the pin's lock pattern with LCKK bit again
GPIOA-&gt;LCKR = GPIO_LCKR_LCKK | GPIO_PIN_0;

// Step 4: Read LCKR to complete the lock sequence
uint32_t temp = GPIOA-&gt;LCKR;

// The pin is now locked, and the configuration cannot be changed until a reset occurs
</code></pre>

    </blockquote>
  </li>
  <li><code class="language-plaintext highlighter-rouge">AFR[2]</code>: Alternate Function Registers (offset <code class="language-plaintext highlighter-rouge">0x20</code>, <code class="language-plaintext highlighter-rouge">0x24</code>).</li>
</ol>

<p>In the following, we will at some of these registers</p>

<h3 id="gpio-portbitsetresetregister-bsrr">GPIO Port <strong>B</strong>it <strong>S</strong>et/<strong>R</strong>eset <strong>R</strong>egister (BSRR)</h3>

<p>This register is used to atomically write to an output pin. It is used this way</p>

<pre><code class="language-cpp">GPIOA -&gt; BSSR = (uint32_t)GPIO_PIN_0 &lt;&lt; 16U;
</code></pre>

<p>But this is exactly what HAL libary’s function <em>HAL_GPIO_WritePin</em> does. Hence, there is no need to access it directly for most cases.</p>

<h2 id="pulse-width-modulation-pwm">Pulse-Width-Modulation (PWM)</h2>

<p>Configuring PWM on the STM32 platform using STM32CubeIDE is a streamlined process. Beginning with the project’s configuration file, <code class="language-plaintext highlighter-rouge">_myproject.ioc_</code>, follow these steps:</p>

<h3 id="system-core-configuration">System Core Configuration</h3>

<ol>
  <li>
    <p><strong>Clock Configuration</strong>:<br />
 Navigate to <strong>System Core</strong> &gt; <code class="language-plaintext highlighter-rouge">RCC</code>. Set both the High-Speed Clock (<code class="language-plaintext highlighter-rouge">HCLK</code>) and Low-Speed Clock (<code class="language-plaintext highlighter-rouge">LCLK</code>) sources to <strong>Crystal/Ceramic Resonator</strong>. This ensures stable and accurate clocking for the timer peripherals.</p>
  </li>
  <li>
    <p><strong>Timer Configuration</strong>:<br />
 Go to <strong>Timers</strong> &gt; <code class="language-plaintext highlighter-rouge">TIM3</code>. The <code class="language-plaintext highlighter-rouge">TIM3</code> peripheral has four channels, each capable of generating PWM signals. For this example, activate <strong>Channel 1</strong> by setting it to <strong>PWM Generation CH1</strong>, optionally the same for channel 2.</p>
  </li>
</ol>

<h3 id="pwm-frequency-and-duty-cycle-calculation">PWM Frequency and Duty Cycle Calculation</h3>

<p>The PWM signal’s frequency is governed by the following equation:</p>

<p>\[
f_\text{PWM} =\frac{f_\text{APB Timer Clock}}{(ARR+1) \cdot (PSC+1)}
\]</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">ARR</code> (Auto-Reload Register)</strong>: Defines the maximum count value before the timer resets.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">PSC</code> (Prescaler)</strong>: Divides the timer clock frequency to adjust the PWM period.</li>
</ul>

<p>Both <code class="language-plaintext highlighter-rouge">ARR</code> and <code class="language-plaintext highlighter-rouge">PSC</code> registers hold values that are decremented by one from their actual count (i.e., an <code class="language-plaintext highlighter-rouge">ARR</code> value of 999 sets the period to 1000 counts).</p>

<p>The duty cycle of the PWM signal is determined by the following relationship:
\[
f_\text{Duty}= \frac{CCR}{ARR} [\%]
\]</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">CCR</code> (Capture Compare Register)</strong>: Controls the pulse width of the PWM signal, directly influencing the duty cycle.</li>
</ul>

<p>These register values can be configured through the “Parameter Settings” window in STM32CubeIDE.</p>

<h3 id="timer-initialization-and-configuration">Timer Initialization and Configuration</h3>

<p>Once the parameters are set in the <code class="language-plaintext highlighter-rouge">.ioc</code> file, STM32CubeIDE generates a private variable <code class="language-plaintext highlighter-rouge">htim3</code> in the <code class="language-plaintext highlighter-rouge">main.c</code> file. This variable is an instance of the <code class="language-plaintext highlighter-rouge">TIM_HandleTypeDef</code> structure, which manages and configures the timer.</p>

<p>This generates a private variable <code class="language-plaintext highlighter-rouge">htim3</code> in <em>main.c</em>. This is the handler of the timer.</p>

<pre><code class="language-cpp">/* Private variables */  
TIM_HandleTypeDef htim3;
</code></pre>

<p><strong><code class="language-plaintext highlighter-rouge">TIM_HandleTypeDef</code> Structure Overview</strong>:</p>

<pre><code class="language-cpp">typedef struct {
  TIM_TypeDef* Instance;      // Points to the TIMx peripheral (e.g., TIM1, TIM2).
  TIM_Base_InitTypeDef init;  // Configuration parameters for the time base.
  HAL_TIM_ActiveChannel;      // Channel
  DMA_HandleTypeDef* hdma[7]; // DMA Handlers array
  HAL_LockTypeDef;            // Locking Object
  HAL_TIM_StateTypeDef;       // State
} TIM_HandleTypeDef;
</code></pre>

<p><strong>Timer Initialization Function</strong>:</p>

<p>The <code class="language-plaintext highlighter-rouge">MX_TIM3_Init()</code> function is responsible for initializing the TIM3 peripheral with the desired settings:</p>

<pre><code class="language-cpp">static void MX_TIM3_Init() {
    // Initialize the TIM3 peripheral handle
    htim3.Instance = TIM3;  
    htim3.Init.Prescaler = 0;  
    htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim3.Init.Period = 65535;  
    htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;  
    htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;  
    // Initialize the timer for PWM operation
    if (HAL_TIM_PWM_Init(&amp;htim3) != HAL_OK) Error_Handler(); 

    // Configure the master configuration for synchronization
    TIM_MasterConfigTypeDef sMasterConfig = {};  
    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;  
    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;  
    // Apply the master configuration settings
    if (HAL_TIMEx_MasterConfigSynchronization(&amp;htim3, &amp;sMasterConfig) != HAL_OK) Error_Handler(); 

    // Configure the output compare (OC) settings for PWM on channel 1 and 2
    TIM_OC_InitTypeDef sConfigOC = {0};  
    sConfigOC.OCMode = TIM_OCMODE_PWM1;  
    sConfigOC.Pulse = 0;  
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;  
    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
    // Configure PWM channel 1 with the above settings
    if (HAL_TIM_PWM_ConfigChannel(&amp;htim3, &amp;sConfigOC, TIM_CHANNEL_1) != HAL_OK) Error_Handler(); 
    // Configure PWM channel 2 with the above settings
    if (HAL_TIM_PWM_ConfigChannel(&amp;htim3, &amp;sConfigOC, TIM_CHANNEL_2) != HAL_OK) Error_Handler();  

    // Call post-initialization function to configure GPIO and other settings
    HAL_TIM_MspPostInit(&amp;htim3);
}
</code></pre>

<h3 id="starting-pwm-output">Starting PWM Output</h3>

<p>To begin PWM signal generation on the configured channels, the following function calls are necessary within the <code class="language-plaintext highlighter-rouge">main()</code> function:</p>

<pre><code class="language-cpp">  
int main(void)  
{
    /* ... */
    
    // Start PWM on Channel 1 
    if (HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_1) != HAL_OK) Error_Handler(); 
    
    // Start PWM on Channel 2
    if (HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2) != HAL_OK) Error_Handler();
    
    /* ... */
}
</code></pre>

<p>These function calls initiate PWM generation on the specified channels, allowing the microcontroller to output the configured PWM signals.</p>

<h2 id="timers">Timers</h2>

<p>General-purpose timers on the STM32 are highly versatile and can be used for a variety of timing tasks. Below are the steps to configure a general-purpose timer (e.g., <code class="language-plaintext highlighter-rouge">TIM2</code>) and set up an interrupt-based event handler.</p>

<h3 id="timer-configuration">Timer Configuration</h3>

<ol>
  <li>
    <p><strong>Set Clock Source</strong>:<br />
 In STM32CubeIDE, set the clock source of <code class="language-plaintext highlighter-rouge">TIM2</code> to <strong>Internal Clock</strong> to use the system clock as the timer’s clock source.</p>
  </li>
  <li>
    <p><strong>Set Counter Period and Prescaler</strong>:<br />
 Configure the <strong>Counter Period</strong> (<code class="language-plaintext highlighter-rouge">ARR</code>) and <strong>Prescaler</strong> (<code class="language-plaintext highlighter-rouge">PSC</code>) values to achieve the desired timer frequency:</p>

    <p>\[
 f_\text{PWM} =\frac{f_\text{Clock Frequency}}{(ARR-1) \cdot (PSC-1)}
 \]</p>

    <p>This equation determines the frequency at which the timer overflows and triggers an interrupt or updates its count.</p>
  </li>
  <li>
    <p><strong>Enable Auto-Reload Preload</strong>:<br />
 Enable the <strong>Auto-Reload Preload</strong> to ensure that the counter resets seamlessly upon reaching the <code class="language-plaintext highlighter-rouge">ARR</code> value.</p>
  </li>
</ol>

<h3 id="initialization-and-interrupt-configuration">Initialization and Interrupt Configuration</h3>

<p>To initialize the timer and configure it for interrupt generation, include the following code in your initialization function:</p>

<pre><code class="language-cpp">static void MX_TIM2_Init(void) {
    // Initialize TIM2
    htim2.Instance = TIM2;  
    // Set prescaler to divide clock by 9600 (96 MHz / 9600 = 10 kHz)
    htim2.Init.Prescaler = 9599;  
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    // Set period for 1 Hz frequency (10 kHz / 10000 = 1 Hz)
    htim2.Init.Period = 9999;
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;  // Enable auto-reload preload
    
    // Initialize the timer
    if (HAL_TIM_Base_Init(&amp;htim2) != HAL_OK) Error_Handler();
    
    // Start the timer with interrupt enabled
    if (HAL_TIM_Base_Start_IT(&amp;htim2) != HAL_OK) Error_Handler(); 
}
</code></pre>

<h3 id="handling-timer-interrupts">Handling Timer Interrupts</h3>

<p>To handle timer interrupts, define the interrupt callback function:</p>

<pre><code class="language-cpp">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    // Check if the interrupt is from TIM2
    if (htim-&gt;Instance == TIM2) {
        // Toggle an LED on GPIO pin PC13 as an example
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);  
    }
}
</code></pre>

<p>This function is called whenever the timer reaches its period value and generates an interrupt, allowing you to execute time-based tasks, such as toggling an LED or triggering other events.</p>

<h2 id="usb-serial-communication-setup">USB Serial Communication Setup</h2>

<p>In this section, we will detail the setup and configuration of the Universal Serial Bus On-The-Go Full Speed (<code class="language-plaintext highlighter-rouge">USB OTG FS</code>) interface on the STM32 platform, which is compliant with the USB 2.0 standard. This interface is crucial for enabling USB communication, requiring a dedicated 48 MHz clock sourced from the High-Speed External (<code class="language-plaintext highlighter-rouge">HSE</code>) oscillator, as specified in the device’s datasheet (refer to section 3.27).</p>

<h3 id="configuring-the-usb-otg-fs-clock">Configuring the USB OTG FS Clock</h3>

<p>To ensure the <code class="language-plaintext highlighter-rouge">USB_OTG_FS</code> peripheral operates correctly, it must be supplied with a precise 48 MHz clock, derived from the High-Speed External (<code class="language-plaintext highlighter-rouge">HSE</code>) oscillator. This clock configuration is critical for maintaining the timing requirements stipulated by the USB 2.0 standard.</p>

<h4 id="step-by-step-clock-setup">Step-by-Step Clock Setup</h4>

<ol>
  <li>
    <p><strong>Activate the HSE and LSE Oscillators</strong>:</p>

    <ul>
      <li>Begin by configuring the RCC (Reset and Clock Control) settings in STM32CubeMX. Set both the High-Speed External (<code class="language-plaintext highlighter-rouge">HSE</code>) and Low-Speed External (<code class="language-plaintext highlighter-rouge">LSE</code>) clocks to use crystal oscillators, which offer superior stability compared to internal RC oscillators.</li>
    </ul>
  </li>
  <li>
    <p><strong>Configure the PLL (Phase-Locked Loop)</strong>:</p>

    <ul>
      <li>
        <p>The main PLL should be configured to generate a system clock that is a multiple of 48 MHz. For instance, if your application allows, you might set the HCLK (High-speed Clock) to 96 MHz, which can then be divided by two to achieve the required 48 MHz for the USB peripheral.</p>
      </li>
      <li>
        <p><strong>Example for STM32F411CEUx</strong>: This microcontroller typically uses a 25 MHz HSE and a 32.786 kHz LSE. Set the PLL to multiply the HSE to achieve a 96 MHz system clock, which can then be divided down to provide the 48 MHz USB clock directly from the Main PLL.</p>
      </li>
      <li>
        <p><strong>Diagram Reference</strong>: The clock tree configuration should be adjusted accordingly to ensure the USB_OTG_FS peripheral is fed the correct 48 MHz signal, as visualized below.</p>
      </li>
    </ul>
  </li>
</ol>

<p><img src="/assets/images/embedded/stm32_cubemx/clock_configuration.webp" alt="Clock Configuration Panel on STM32 CubeMX" /></p>

<p><strong>Figure 1: Clock Configuration for <code class="language-plaintext highlighter-rouge">USB_OTG_FS</code></strong></p>

<h3 id="usb-peripheral-configuration-in-stm32cubemx">USB Peripheral Configuration in STM32CubeMX</h3>

<p>After ensuring the clock is properly configured, proceed with setting up the USB OTG FS peripheral to handle USB communication at the hardware level.</p>

<h4 id="detailed-configuration-steps">Detailed Configuration Steps</h4>

<ol>
  <li>
    <p><strong>Enable USB OTG FS</strong>:</p>

    <ul>
      <li>Within STM32CubeMX, navigate to <strong>Connectivity</strong> and select <strong>USB_OTG_FS</strong>.</li>
      <li>Set the mode to <strong>Device Only</strong>, as this will configure the STM32 to act as a USB device when connected to a host system such as a PC.</li>
    </ul>
  </li>
  <li>
    <p><strong>Set Up the USB Device Middleware</strong>:</p>

    <ul>
      <li>
        <p>Under <strong>Middleware</strong>, select <strong>USB_DEVICE</strong>. For serial communication over USB, choose the <strong>Communication Device Class (CDC)</strong>, commonly referred to as <em>Virtual COM Port</em>. This selection enables the microcontroller to communicate with a host as if it were a standard serial port.</p>
      </li>
      <li>
        <p>Customize the USB device descriptors (such as the <code class="language-plaintext highlighter-rouge">PRODUCT_String</code>) within the <strong>Device Descriptor</strong> settings. These descriptors define how the USB device is identified by the host system, allowing for easier recognition and differentiation.</p>
      </li>
      <li>
        <p><strong>Note</strong>: The USB_DEVICE middleware operates in conjunction with the <code class="language-plaintext highlighter-rouge">STM32_USB_DEVICE_Library</code>, which houses the core USB functionality, referred to as <code class="language-plaintext highlighter-rouge">usb_core</code>. The core library manages fundamental USB operations but delegates higher-level communication protocols to other modules.</p>
      </li>
    </ul>
  </li>
</ol>

<h3 id="memory-management-adjusting-the-heap-size">Memory Management: Adjusting the Heap Size</h3>

<p>To ensure the microcontroller can handle USB communication efficiently, particularly when dealing with data buffers, it is necessary to adjust the default heap size.</p>

<h4 id="heap-size-adjustment">Heap Size Adjustment</h4>

<ol>
  <li>
    <p><strong>Increase Heap Size</strong>:</p>

    <ul>
      <li>
        <p>Access the <strong>Project Manager</strong> tab in STM32CubeMX. By default, the heap size may be set to 0x200 (512 bytes), which is often insufficient for USB operations.</p>
      </li>
      <li>
        <p>Increase the heap size to 0x600 (1536 bytes). This additional memory allocation is crucial for accommodating the buffers required by the USB communication stack, ensuring smooth data transmission and reception.</p>
      </li>
    </ul>
  </li>
</ol>

<p>To ensure the heap size has increased we can look at the linker script</p>

<pre><code class="language-cpp">/* Entry Point */
ENTRY(Reset_Handler)

/* Highest address of the user mode stack */
_estack = ORIGIN(RAM) + LENGTH(RAM);    /* End of RAM */

/* Define heap and stack sizes */
_Min_Heap_Size = 0x600;      /* Required amount of heap (1.5KB) */
_Min_Stack_Size = 0x400;     /* Required amount of stack (1KB) */

/* Specify the memory areas */
MEMORY
{
  RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 128K
  FLASH (rx)     : ORIGIN = 0x08000000, LENGTH = 512K
}
</code></pre>

<ul>
  <li><strong>Heap Size</strong>: Updated to <code class="language-plaintext highlighter-rouge">0x600</code> (1536 bytes) to ensure sufficient memory for USB operations.</li>
  <li><strong>Stack Size</strong>: Maintained at <code class="language-plaintext highlighter-rouge">0x400</code> (1024 bytes) to support typical stack usage scenarios.</li>
</ul>

<h3 id="customizing-usb-communication-in-usbd_cdc_ifc">Customizing USB Communication in <code class="language-plaintext highlighter-rouge">usbd_cdc_if.c</code></h3>

<p>To ensure that the device and the host computer agree on communication parameters such as baud rate, parity, and stop bits, the <code class="language-plaintext highlighter-rouge">usbd_cdc_if.c</code> file must be modified. This file also handles the reception of data from the USB interface.</p>

<h4 id="modifying-line-coding-commands">Modifying Line Coding Commands</h4>

<ol>
  <li>
    <p><strong>Storing Line Coding Information</strong>:</p>

    <ul>
      <li>To handle the Line Coding commands, add a variable of type <code class="language-plaintext highlighter-rouge">USBD_CDC_LineCodingTypeDef</code> to store the communication settings.</li>
    </ul>

    <p>In the block for adding private variables (<code class="language-plaintext highlighter-rouge">PV</code>):</p>

    <pre><code class="language-cpp"> /* USER CODE BEGIN PV */
 /* Private variables ---------------------------------------------------------*/
 USBD_CDC_LineCodingTypeDef LineCoding;
 /* USER CODE END PV */
</code></pre>
  </li>
  <li>
    <p><strong>Handling SET and GET Line Coding Requests</strong>:</p>

    <ul>
      <li>Modify the <code class="language-plaintext highlighter-rouge">CDC_Control_FS</code> function to handle <code class="language-plaintext highlighter-rouge">CDC_SET_LINE_CODING</code> and <code class="language-plaintext highlighter-rouge">CDC_GET_LINE_CODING</code> requests. This ensures the device correctly receives and responds to the host’s communication settings.</li>
    </ul>

    <pre><code class="language-cpp"> case CDC_SET_LINE_CODING:
     LineCoding.bitrate = 
     (uint32_t)((pbuf[0]) | (pbuf[1] &lt;&lt; 8) | (pbuf[2] &lt;&lt; 16) | (pbuf[3] &lt;&lt; 24));
     LineCoding.format = pbuf[4];
     LineCoding.paritytype = pbuf[5];
     LineCoding.datatype = pbuf[6];
 break;
 case CDC_GET_LINE_CODING:
     pbuf[0] = (uint8_t)(LineCoding.bitrate);
     pbuf[1] = (uint8_t)(LineCoding.bitrate &gt;&gt; 8);
     pbuf[2] = (uint8_t)(LineCoding.bitrate &gt;&gt; 16);
     pbuf[3] = (uint8_t)(LineCoding.bitrate &gt;&gt; 24);
     pbuf[4] = LineCoding.format;
     pbuf[5] = LineCoding.paritytype;
     pbuf[6] = LineCoding.datatype;
 break;
</code></pre>

    <ul>
      <li>This implementation ensures that both the computer and the device agree on the communication parameters.</li>
    </ul>
  </li>
</ol>

<h4 id="handling-data-reception">Handling Data Reception</h4>

<ol>
  <li>
    <p><strong>Creating a Hook for Data Reception</strong>:</p>

    <ul>
      <li>Define a weak function <code class="language-plaintext highlighter-rouge">CDC_Receive_Handler</code> that can be overridden to handle incoming data. This provides flexibility by allowing custom data handling outside of the default library implementation.</li>
    </ul>

    <p>In the block for private function declarations:</p>

    <ul>
      <li>A weak function is only compiled if implemented; otherwise, all calls to it are ignored, which helps avoid unnecessary code execution.</li>
    </ul>

    <pre><code class="language-cpp"> __weak void CDC_Receive_Handler(uint8_t* pbuf, uint32_t *Len);
</code></pre>
  </li>
  <li>
    <p><strong>Modifying <code class="language-plaintext highlighter-rouge">CDC_Receive_FS</code> Function</strong>:</p>

    <ul>
      <li>Modify the <code class="language-plaintext highlighter-rouge">CDC_Receive_FS</code> function to call the <code class="language-plaintext highlighter-rouge">CDC_Receive_Handler</code> whenever data is received. This ensures that received data is processed as soon as it arrives.</li>
    </ul>

    <pre><code class="language-cpp"> static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)
 {
   /* USER CODE BEGIN 6 */
   USBD_CDC_SetRxBuffer(&amp;hUsbDeviceFS, &amp;Buf[0]);
   USBD_CDC_ReceivePacket(&amp;hUsbDeviceFS);
   CDC_Receive_Handler(Buf, Len);   /* &lt;-- added here */
   return (USBD_OK);
   /* USER CODE END 6 */
 }
</code></pre>

    <ul>
      <li>This function must execute quickly to ensure that the USB interface can continue processing incoming data without delays.</li>
    </ul>
  </li>
</ol>

<h3 id="finalizing-the-usb-communication-setup">Finalizing the USB Communication Setup</h3>

<p>Once the clock and peripheral configurations are complete, and the project code is generated by STM32CubeMX, the final step involves refining the generated code to suit your application’s specific needs.</p>

<h4 id="code-customization">Code Customization</h4>

<ol>
  <li>
    <p><strong>Generated Code Overview</strong>:</p>

    <ul>
      <li>STM32CubeMX will generate several key files, including <code class="language-plaintext highlighter-rouge">usb_device.c</code>, <code class="language-plaintext highlighter-rouge">usbd_desc.c</code>, and <code class="language-plaintext highlighter-rouge">usb_cdc_if.c</code>. These files contain the foundational code for USB communication, including initialization routines and descriptor settings.</li>
    </ul>
  </li>
  <li>
    <p><strong>Editing <code class="language-plaintext highlighter-rouge">usb_cdc_if.c</code></strong>:</p>

    <ul>
      <li>
        <p>The file <code class="language-plaintext highlighter-rouge">usb_cdc_if.c</code> is where the core data handling functions are implemented. This is the primary location for customizing how data is sent and received over USB. Modify these functions to align with your application’s communication protocol and data handling requirements.</p>
      </li>
      <li>
        <p><strong>Middleware Structure</strong>:</p>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">usb_device.c</code>: Manages the core USB device functionality.</li>
          <li><code class="language-plaintext highlighter-rouge">usbd_desc.c</code>: Contains the USB device descriptors, which define how the device appears to the host.</li>
          <li><code class="language-plaintext highlighter-rouge">usb_cdc_if.c</code>: Implements the interface for the CDC class, handling data transfers between the microcontroller and the USB host.</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p>By carefully following these steps, you will configure a robust and efficient USB communication interface on your STM32 microcontroller. The process involves precise clock setup, enabling and configuring the appropriate peripherals, adjusting memory allocations, and customizing the generated code to meet your application’s specific needs. This comprehensive approach ensures reliable and high-performance USB communication, suitable for a wide range of embedded applications.</p>

<h2 id="configuring-analog-channels-on-stm32">Configuring Analog Channels on STM32</h2>

<p>Setting up analog channels on the STM32 microcontroller involves several key steps, particularly when configuring the ADC (Analog-to-Digital Converter) to read analog signals. This section will guide you through the process of declaring pins as analog inputs, configuring the ADC for optimal performance, and utilizing internal references such as the temperature sensor and voltage reference.</p>

<h3 id="selecting-analog-input-pins">Selecting Analog Input Pins</h3>

<p>Before proceeding with the configuration, it’s essential to identify which pins you will declare as analog inputs. This decision is crucial because changing the configuration later can be complex and may require reworking the hardware setup or significant software adjustments.</p>

<h2 id="adc-configuration">ADC Configuration</h2>

<p>The ADC peripheral in STM32 microcontrollers is highly versatile, capable of converting multiple analog inputs simultaneously using DMA (Direct Memory Access) for efficient data handling. The following steps outline the configuration process:</p>

<ol>
  <li>
    <p><strong>Selecting ADC Channels (ADCx)</strong>:</p>

    <ul>
      <li><strong>Input Channels (INx)</strong>: Choose the specific analog pins (INx) you intend to use as input channels. Each INx corresponds to a physical pin on the microcontroller.</li>
      <li><strong>Internal Channels</strong>: Additionally, you can select internal channels such as the temperature sensor and the internal voltage reference (<code class="language-plaintext highlighter-rouge">Vrefint</code>), which are invaluable for monitoring the microcontroller’s operating conditions.</li>
    </ul>
  </li>
  <li>
    <p><strong>Configuring DMA Settings</strong>:</p>

    <ul>
      <li><strong>DMA Channel</strong>: Add <code class="language-plaintext highlighter-rouge">ADC1</code> to the DMA settings. This will allow the ADC to transfer conversion results directly to memory without CPU intervention.</li>
      <li><strong>Data Width</strong>: Set the data width to “WORD” to ensure that each conversion result is stored in a 32-bit word format.</li>
      <li><strong>Mode</strong>: Enable “Circular” mode for DMA. This mode allows continuous ADC conversions, where the DMA automatically restarts after each full transfer, ideal for real-time data acquisition.</li>
    </ul>
  </li>
  <li>
    <p><strong>Adjusting ADC Parameters</strong>:</p>

    <ul>
      <li><strong>Continuous Conversion Mode</strong>: Enable this mode to allow the ADC to continuously convert the selected channels without requiring additional triggers.</li>
      <li><strong>DMA Continuous Request</strong>: Enable this to keep the DMA in sync with the continuous ADC conversions, ensuring that each conversion result is automatically transferred to memory.</li>
      <li><strong>Number of Conversions</strong>: Set this parameter to the number of channels you have configured. This determines how many conversions the ADC performs before resetting.</li>
      <li><strong>Clock Prescaler</strong>: Set the prescaler to divide <code class="language-plaintext highlighter-rouge">PCLK2</code> by 4. Given our configuration with a <code class="language-plaintext highlighter-rouge">PCLK2</code> of 96 MHz, this results in an ADC clock of 24 MHz.</li>
      <li><strong>Sampling Time Calculation</strong>: To determine the conversion time, divide the number of cycles by the ADC clock. For example:
        <ul>
          <li><strong>3 Cycles</strong>: 324 MHz=0.125 microseconds\frac{3}{24 \text{ MHz}} = 0.125 \text{ microseconds}24 MHz3​=0.125 microseconds. This is extremely fast and might not be suitable for accurate conversions.</li>
          <li><strong>480 Cycles</strong>: 48024 MHz=20 microseconds\frac{480}{24 \text{ MHz}} = 20 \text{ microseconds}24 MHz480​=20 microseconds. This is a more reasonable time, balancing speed and accuracy for most applications.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Implementing the ADC in the Main Program</strong>:</p>

    <ul>
      <li>After configuring the ADC, a handle (<code class="language-plaintext highlighter-rouge">hadc1</code>) will be available in your main program. To store the ADC conversion results, declare a buffer:</li>
    </ul>

    <pre><code class="language-cpp"> uint32_t pData[2] = {0};  // Buffer to hold ADC conversion results
</code></pre>

    <ul>
      <li>Start the ADC with DMA to begin storing conversion results in the buffer:</li>
    </ul>

    <pre><code class="language-cpp"> HAL_ADC_Start_DMA(&amp;hadc1, pData, 2);  // Start ADC with DMA, storing results in pData
</code></pre>
  </li>
</ol>

<h2 id="internal-voltage-reference-vrefint">Internal Voltage Reference (<code class="language-plaintext highlighter-rouge">Vrefint</code>)</h2>

<p>The STM32 microcontrollers include an internal voltage reference (<code class="language-plaintext highlighter-rouge">Vrefint</code>), which is particularly useful for compensating for power supply variations or for calibrating measurements. According to the STM32 datasheet (Section 6.3.23), the typical value of <code class="language-plaintext highlighter-rouge">Vrefint</code> is 1.21V. You can use this reference to calculate the actual voltage of an input pin as follows:</p>

<pre><code class="language-cpp">voltage = value_pinA0 * 1210 / value_Vrefint;  // Calculate voltage in mV
</code></pre>

<p>This formula assumes that <code class="language-plaintext highlighter-rouge">value_pinA0</code> is the ADC reading of the target pin, and <code class="language-plaintext highlighter-rouge">value_Vrefint</code> is the ADC reading of <code class="language-plaintext highlighter-rouge">Vrefint</code>. The result gives you the pin voltage in millivolts.</p>

<h3 id="utilizing-the-internal-temperature-sensor">Utilizing the Internal Temperature Sensor</h3>

<p>The internal temperature sensor in STM32 microcontrollers is useful for monitoring the temperature of the microcontroller itself, which can be an indicator of ambient temperature or the device’s thermal performance. However, note that the sensor primarily measures the temperature of the silicon die, which may not reflect rapid ambient temperature changes due to the sensor’s thermal inertia.</p>

<h4 id="calculating-temperature">Calculating Temperature</h4>

<p>The temperature can be calculated using the following formula derived from the sensor’s characteristics:</p>

<p>\[
T= \frac{V_\text{temp} - V_{25}}{ \text{slope}} + 25
\]</p>

<p>Where:</p>

<ul>
  <li>VtempV_{temp}Vtemp​ is the ADC reading of the temperature sensor.</li>
  <li>V25V_{25}V25​ is the voltage corresponding to 25°C, typically 0.76V (as per Section 6.3.21 of the datasheet).</li>
  <li>The slope is the change in voltage per degree Celsius.</li>
</ul>

<p>To implement this in code, assuming you are working in millivolts, the formula can be expressed as:</p>

<pre><code class="language-cpp">temp = ((V_temp * 3300) / 4095 - 760) * 1000 / slope + 25;
</code></pre>

<p>For the STM32, where the slope might be around 2.5 mV/°C, you could simplify this further:</p>

<pre><code class="language-cpp">temp = ((V_temp * 33000) / 4095 - 7600 + 25000) / 25;
</code></pre>

<p>This calculation yields the temperature in degrees Celsius, adjusting for the reference voltage and typical sensor characteristics.</p>]]></content><author><name></name></author><category term="Embedded-Development" /><category term="STM32" /><category term="STM32F411CEU6" /><category term="Embedded" /><category term="STM32" /><category term="blackpill" /><category term="STM32F411CEU6" /><category term="ARM" /><category term="Cortex-m4" /><summary type="html"><![CDATA[]]></summary></entry></feed>